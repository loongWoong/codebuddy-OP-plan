# Datart 项目代码风格和规范

本文档是 datart 项目的官方编码规范，适用于前端（React/TypeScript）和后端（Java/Spring Boot）开发。所有开发者必须严格遵循此规范。

## 2.1 目录与文件命名

### 规则 2.1.1：前端目录使用 camelCase，组件目录使用 PascalCase
前端普通目录使用小驼峰命名，React 组件目录使用大驼峰命名。

**正例：**
```
frontend/src/
├── app/
├── components/
│   ├── ChartGraph/
│   │   └── BasicOutlineMapChart/
│   └── DataTable/
├── pages/
│   └── MainPage/
├── utils/
└── types/
```

**反例：**
```
frontend/src/
├── App/           # 普通目录不应使用大驼峰
├── chart-graph/   # 组件目录不应使用短横线
├── data_table/    # 不应使用下划线
└── Utils/         # 普通目录不应使用大驼峰
```

**自动校验配置：**
```bash
# .eslintrc.js 中添加文件命名规则
rules: {
  "unicorn/filename-case": [
    "error",
    {
      "cases": {
        "camelCase": true,
        "pascalCase": true
      }
    }
  ]
}
```

### 规则 2.1.2：后端包名使用全小写，类文件使用 PascalCase
Java 包名必须全小写，类文件名必须与类名一致使用大驼峰命名。

**正例：**
```
server/src/main/java/datart/server/
├── controller/
│   ├── MetricDefinitionController.java
│   └── UserController.java
├── service/
│   └── impl/
│       └── MetricDefinitionServiceImpl.java
└── base/
    ├── dto/
    └── params/
```

**反例：**
```
server/src/main/java/datart/server/
├── Controller/                    # 包名不应大写
├── Service_Impl/                  # 包名不应使用下划线
├── metricDefinitionController.java # 类文件名应与类名一致
└── metric-controller.java         # 不应使用短横线
```

**自动校验配置：**
```xml
<!-- checkstyle.xml -->
<module name="PackageName">
    <property name="format" value="^[a-z]+(\.[a-z][a-z0-9]*)*$"/>
</module>
<module name="TypeName">
    <property name="format" value="^[A-Z][a-zA-Z0-9]*$"/>
</module>
```

### 规则 2.1.3：配置文件使用短横线命名
所有配置文件统一使用短横线分隔命名。

**正例：**
```
.eslintrc.js
.prettierrc
application.yml
application-dev.yml
tsconfig.json
package.json
```

**反例：**
```
eslint_config.js    # 不应使用下划线
prettier.config.js  # 应使用 .prettierrc
applicationDev.yml  # 不应使用驼峰
```

**自动校验配置：**
```bash
# 在 package.json 的 scripts 中添加
"check-config": "find . -name '*.config.js' -o -name '*_config.*' | grep -v node_modules && exit 1 || exit 0"
```

## 2.2 模块与包结构

### 规则 2.2.1：前端按功能模块组织，最大嵌套深度不超过 4 层
前端代码按业务功能模块组织，目录嵌套深度不得超过 4 层。

**正例：**
```typescript
// src/app/pages/MainPage/pages/MetricPage/index.tsx
export const MetricPage: React.FC = () => {
  return <div>Metric Management</div>;
};

// 目录结构深度：src(1)/app(2)/pages(3)/MainPage(4) ✓
```

**反例：**
```typescript
// src/app/pages/main/components/metric/management/list/item/index.tsx
// 目录结构深度超过 4 层 ✗
```

**自动校验配置：**
```bash
# 检查目录深度的脚本
find src -type d | awk -F'/' 'NF > 6 {print "目录深度超过4层: " $0; exit 1}'
```

### 规则 2.2.2：后端采用分层架构，包结构固定为 controller/service/mapper
后端严格按照 MVC 分层架构组织，包结构层次固定。

**正例：**
```java
// datart.server.controller.MetricDefinitionController
@RestController
@RequestMapping("/metrics")
public class MetricDefinitionController extends BaseController {
    private final MetricDefinitionService metricDefinitionService;
}

// datart.server.service.impl.MetricDefinitionServiceImpl
@Service
public class MetricDefinitionServiceImpl extends BaseService 
    implements MetricDefinitionService {
}
```

**反例：**
```java
// 不应将业务逻辑写在 Controller 中
@RestController
public class MetricController {
    public ResponseData create() {
        // 直接在 Controller 中写业务逻辑 ✗
        MetricDefinition metric = new MetricDefinition();
        // ... 复杂业务逻辑
    }
}
```

**自动校验配置：**
```xml
<!-- maven-checkstyle-plugin 配置 -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-checkstyle-plugin</artifactId>
    <configuration>
        <configLocation>checkstyle.xml</configLocation>
        <includeTestSourceDirectory>true</includeTestSourceDirectory>
    </configuration>
</plugin>
```

### 规则 2.2.3：每个模块的导入语句不超过 20 个
单个文件的 import 语句数量不得超过 20 个，超过则需要重构。

**正例：**
```typescript
// 导入语句控制在合理范围内
import React, { useState, useEffect } from 'react';
import { Button, Table, Modal } from 'antd';
import { useTranslation } from 'react-i18next';
import { MetricDefinitionDto } from 'app/types/MetricDefinition';
import { metricService } from 'app/services/metricService';
// ... 总计不超过 20 个导入
```

**反例：**
```typescript
// 导入过多，需要重构
import React from 'react';
import { useState } from 'react';
import { useEffect } from 'react';
// ... 超过 20 个单独的导入语句 ✗
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "import/max-dependencies": ["error", {"max": 20}]
}
```

## 2.3 变量、函数、类、接口命名

### 规则 2.3.1：前端变量和函数使用 camelCase，常量使用 SCREAMING_SNAKE_CASE
TypeScript/JavaScript 变量和函数使用小驼峰，常量使用全大写下划线。

**正例：**
```typescript
// 变量和函数
const metricDefinition = new MetricDefinition();
const isLoading = false;
const handleSubmit = () => {};
const getUserProfile = async () => {};

// 常量
const API_BASE_URL = 'http://localhost:8080/api/v1';
const MAX_RETRY_COUNT = 3;
const DEFAULT_PAGE_SIZE = 20;
```

**反例：**
```typescript
// 变量命名错误
const MetricDefinition = {};     // 应使用 camelCase
const is_loading = false;        // 不应使用下划线
const HandleSubmit = () => {};   // 函数不应使用 PascalCase

// 常量命名错误
const apiBaseUrl = 'http://...'; // 常量应使用 SCREAMING_SNAKE_CASE
const maxRetryCount = 3;         // 常量应使用 SCREAMING_SNAKE_CASE
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "camelcase": ["error", {
    "properties": "always",
    "ignoreDestructuring": false,
    "ignoreImports": false,
    "ignoreGlobals": false
  }],
  "@typescript-eslint/naming-convention": [
    "error",
    {
      "selector": "variable",
      "format": ["camelCase", "UPPER_CASE"]
    },
    {
      "selector": "function",
      "format": ["camelCase"]
    }
  ]
}
```

### 规则 2.3.2：后端类名使用 PascalCase，方法和变量使用 camelCase
Java 类名使用大驼峰，方法名和变量名使用小驼峰。

**正例：**
```java
// 类名
public class MetricDefinitionController extends BaseController {
    
    // 成员变量
    private final MetricDefinitionService metricDefinitionService;
    
    // 方法名
    public ResponseData<MetricDefinitionDto> create(
        @Valid @RequestBody MetricDefinitionCreateParam createParam) {
        MetricDefinitionDto result = metricDefinitionService.create(createParam);
        return ResponseData.success(result);
    }
    
    // 局部变量
    private void validateMetricCode(String orgId, String code) {
        boolean codeExists = metricDefinitionService.checkCodeExists(orgId, code, null);
        if (codeExists) {
            throw new BusinessException("指标编码已存在");
        }
    }
}
```

**反例：**
```java
// 类名错误
public class metricDefinitionController {  // 应使用 PascalCase
public class Metric_Definition_Service {   // 不应使用下划线

// 方法名错误
public ResponseData Create() {}            // 应使用 camelCase
public void Validate_Code() {}             // 不应使用下划线

// 变量名错误
private String MetricName;                 // 应使用 camelCase
private boolean is_valid;                  // 不应使用下划线
```

**自动校验配置：**
```xml
<!-- checkstyle.xml -->
<module name="MethodName">
    <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
</module>
<module name="MemberName">
    <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
</module>
<module name="LocalVariableName">
    <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
</module>
```

### 规则 2.3.3：接口名以 I 开头，DTO 类以 Dto 结尾，参数类以 Param 结尾
接口、DTO、参数类必须按照固定后缀命名。

**正例：**
```typescript
// 前端接口定义
interface IMetricDefinition {
  id: string;
  name: string;
  code: string;
}

interface IMetricService {
  create(param: MetricCreateParam): Promise<MetricDefinitionDto>;
  update(param: MetricUpdateParam): Promise<MetricDefinitionDto>;
}
```

```java
// 后端类定义
public class MetricDefinitionDto {
    private String id;
    private String name;
    private String code;
}

public class MetricDefinitionCreateParam {
    @NotBlank
    private String name;
    @NotBlank
    private String code;
}
```

**反例：**
```typescript
// 接口命名错误
interface MetricDefinition {}      // 应以 I 开头
interface MetricServiceInterface {} // 不应使用 Interface 后缀
```

```java
// 类命名错误
public class MetricDefinition {}    // DTO 应以 Dto 结尾
public class MetricCreateRequest {} // 参数类应以 Param 结尾
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "@typescript-eslint/naming-convention": [
    "error",
    {
      "selector": "interface",
      "format": ["PascalCase"],
      "prefix": ["I"]
    }
  ]
}
```

## 2.4 代码格式与缩进

### 规则 2.4.1：使用 2 个空格缩进，行宽限制 80 字符
所有代码文件统一使用 2 个空格缩进，单行长度不超过 80 字符。

**正例：**
```typescript
// 2 个空格缩进，行宽 80 字符内
const MetricDefinitionForm: React.FC<IProps> = ({ 
  initialValues, 
  onSubmit 
}) => {
  const [form] = Form.useForm();
  const { t } = useTranslation();
  
  const handleSubmit = async (values: MetricCreateParam) => {
    try {
      await onSubmit(values);
      message.success(t('common.success'));
    } catch (error) {
      message.error(t('common.error'));
    }
  };
  
  return (
    <Form
      form={form}
      layout="vertical"
      initialValues={initialValues}
      onFinish={handleSubmit}
    >
      <Form.Item
        name="name"
        label={t('metric.name')}
        rules={[{ required: true, message: t('metric.name.required') }]}
      >
        <Input placeholder={t('metric.name.placeholder')} />
      </Form.Item>
    </Form>
  );
};
```

**反例：**
```typescript
// 4 个空格缩进（错误）
const MetricDefinitionForm: React.FC<IProps> = ({ initialValues, onSubmit }) => {
    const [form] = Form.useForm();
    
    // 行宽超过 80 字符（错误）
    const handleSubmit = async (values: MetricCreateParam) => {
        try {
            await onSubmit(values);
            message.success('操作成功，指标定义已创建，请查看指标列表确认结果');
        } catch (error) {
            message.error('操作失败，请检查网络连接和输入参数是否正确，然后重试');
        }
    };
};
```

**自动校验配置：**
```json
// .prettierrc
{
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "semi": true,
  "singleQuote": true,
  "trailingComma": "all",
  "arrowParens": "avoid",
  "endOfLine": "auto"
}
```

### 规则 2.4.2：Java 代码使用 4 个空格缩进，行宽限制 120 字符
Java 代码使用 4 个空格缩进，单行长度不超过 120 字符。

**正例：**
```java
@RestController
@RequestMapping("/metrics")
@Validated
public class MetricDefinitionController extends BaseController {

    private final MetricDefinitionService metricDefinitionService;

    public MetricDefinitionController(MetricDefinitionService metricDefinitionService) {
        this.metricDefinitionService = metricDefinitionService;
    }

    @ApiOperation("创建指标定义")
    @PostMapping
    public ResponseData<MetricDefinitionDto> create(
            @Valid @RequestBody MetricDefinitionCreateParam createParam) {
        MetricDefinitionDto result = metricDefinitionService.create(createParam);
        return ResponseData.success(result);
    }

    @ApiOperation("根据状态获取组织下的指标列表")
    @GetMapping("/org/{orgId}/status/{status}")
    public ResponseData<List<MetricDefinitionDto>> listByOrgIdAndStatus(
            @ApiParam("组织ID") @PathVariable @NotBlank String orgId,
            @ApiParam("状态") @PathVariable @NotBlank String status) {
        List<MetricDefinitionDto> result = 
            metricDefinitionService.listByOrgIdAndStatus(orgId, status);
        return ResponseData.success(result);
    }
}
```

**反例：**
```java
// 2 个空格缩进（错误）
@RestController
public class MetricDefinitionController {
  private final MetricDefinitionService service;
  
  // 行宽超过 120 字符（错误）
  public ResponseData<List<MetricDefinitionDto>> listByOrgIdAndStatus(@PathVariable String orgId, @PathVariable String status) {
    return ResponseData.success(metricDefinitionService.listByOrgIdAndStatus(orgId, status));
  }
}
```

**自动校验配置：**
```xml
<!-- checkstyle.xml -->
<module name="Indentation">
    <property name="basicOffset" value="4"/>
    <property name="braceAdjustment" value="0"/>
    <property name="caseIndent" value="4"/>
</module>
<module name="LineLength">
    <property name="max" value="120"/>
    <property name="ignorePattern" value="^package.*|^import.*|a href|href|http://|https://|ftp://"/>
</module>
```

### 规则 2.4.3：大括号使用 K&R 风格，左大括号不换行
所有语言统一使用 K&R 大括号风格。

**正例：**
```typescript
// TypeScript K&R 风格
if (condition) {
  doSomething();
} else {
  doSomethingElse();
}

const obj = {
  name: 'metric',
  code: 'M001',
};

function handleSubmit() {
  if (isValid) {
    submit();
  }
}
```

```java
// Java K&R 风格
if (condition) {
    doSomething();
} else {
    doSomethingElse();
}

public void create() {
    if (isValid()) {
        save();
    }
}
```

**反例：**
```typescript
// Allman 风格（错误）
if (condition) 
{
  doSomething();
}

// GNU 风格（错误）
if (condition)
  {
    doSomething();
  }
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "brace-style": ["error", "1tbs", { "allowSingleLine": true }]
}
```

## 2.5 注释与文档注释

### 规则 2.5.1：所有公共 API 必须有 JSDoc/JavaDoc 注释
公共接口、类、方法必须提供完整的文档注释。

**正例：**
```typescript
/**
 * 指标定义服务
 * 提供指标的创建、更新、删除、查询等功能
 */
export class MetricDefinitionService {
  
  /**
   * 创建指标定义
   * @param param 创建参数
   * @param param.name 指标名称，必填，长度1-50字符
   * @param param.code 指标编码，必填，组织内唯一
   * @param param.expression 指标表达式，必填
   * @returns Promise<MetricDefinitionDto> 创建成功的指标信息
   * @throws {BusinessException} 当指标编码已存在时抛出异常
   * @example
   * ```typescript
   * const result = await metricService.create({
   *   name: '用户数',
   *   code: 'USER_COUNT',
   *   expression: 'COUNT(DISTINCT user_id)'
   * });
   * ```
   */
  async create(param: MetricCreateParam): Promise<MetricDefinitionDto> {
    return this.http.post('/metrics', param);
  }
}
```

```java
/**
 * 指标定义控制器
 * 提供指标定义的 REST API 接口
 * 
 * @author datart-team
 * @since 1.0.0
 */
@RestController
@RequestMapping("/metrics")
public class MetricDefinitionController extends BaseController {

    /**
     * 创建指标定义
     * 
     * @param createParam 创建参数，包含指标名称、编码、表达式等信息
     * @return ResponseData<MetricDefinitionDto> 包装的响应数据，包含创建成功的指标信息
     * @throws BusinessException 当指标编码已存在或参数验证失败时抛出
     * @see MetricDefinitionCreateParam
     * @see MetricDefinitionDto
     */
    @ApiOperation("创建指标定义")
    @PostMapping
    public ResponseData<MetricDefinitionDto> create(
            @Valid @RequestBody MetricDefinitionCreateParam createParam) {
        MetricDefinitionDto result = metricDefinitionService.create(createParam);
        return ResponseData.success(result);
    }
}
```

**反例：**
```typescript
// 缺少注释（错误）
export class MetricDefinitionService {
  async create(param: MetricCreateParam) {
    return this.http.post('/metrics', param);
  }
}

// 注释不完整（错误）
/**
 * 创建指标
 */
async create(param: MetricCreateParam) {
  // 缺少参数说明、返回值说明、异常说明
}
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "jsdoc/require-jsdoc": ["error", {
    "require": {
      "FunctionDeclaration": true,
      "MethodDefinition": true,
      "ClassDeclaration": true
    }
  }],
  "jsdoc/require-param": "error",
  "jsdoc/require-returns": "error"
}
```

### 规则 2.5.2：复杂业务逻辑必须添加行内注释说明
超过 10 行的复杂逻辑块必须添加注释说明。

**正例：**
```typescript
const validateMetricExpression = (expression: string): boolean => {
  // 检查表达式是否为空
  if (!expression || expression.trim().length === 0) {
    return false;
  }
  
  // 检查是否包含危险的 SQL 关键字
  const dangerousKeywords = ['DROP', 'DELETE', 'UPDATE', 'INSERT', 'TRUNCATE'];
  const upperExpression = expression.toUpperCase();
  
  for (const keyword of dangerousKeywords) {
    if (upperExpression.includes(keyword)) {
      return false;
    }
  }
  
  // 验证表达式的基本语法结构
  // 检查括号是否匹配
  let parenthesesCount = 0;
  for (const char of expression) {
    if (char === '(') {
      parenthesesCount++;
    } else if (char === ')') {
      parenthesesCount--;
      if (parenthesesCount < 0) {
        return false; // 右括号多于左括号
      }
    }
  }
  
  return parenthesesCount === 0; // 括号必须完全匹配
};
```

**反例：**
```typescript
// 复杂逻辑缺少注释（错误）
const validateMetricExpression = (expression: string): boolean => {
  if (!expression || expression.trim().length === 0) {
    return false;
  }
  
  const dangerousKeywords = ['DROP', 'DELETE', 'UPDATE', 'INSERT', 'TRUNCATE'];
  const upperExpression = expression.toUpperCase();
  
  for (const keyword of dangerousKeywords) {
    if (upperExpression.includes(keyword)) {
      return false;
    }
  }
  
  let parenthesesCount = 0;
  for (const char of expression) {
    if (char === '(') {
      parenthesesCount++;
    } else if (char === ')') {
      parenthesesCount--;
      if (parenthesesCount < 0) {
        return false;
      }
    }
  }
  
  return parenthesesCount === 0;
};
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "max-lines-per-function": ["warn", {
    "max": 50,
    "skipBlankLines": true,
    "skipComments": true
  }]
}
```

### 规则 2.5.3：TODO 注释必须包含责任人和截止时间
所有 TODO 注释必须标明责任人和预期完成时间。

**正例：**
```typescript
// TODO: @zhangsan 2024-02-01 实现指标表达式的语法高亮功能
const renderExpressionEditor = () => {
  return <Input.TextArea />;
};

// FIXME: @lisi 2024-01-15 修复指标删除时的权限检查问题
const deleteMetric = async (id: string) => {
  // 临时跳过权限检查
  await metricService.delete(id);
};
```

**反例：**
```typescript
// TODO: 实现语法高亮（错误：缺少责任人和时间）
// TODO 添加权限检查（错误：格式不规范）
// FIXME 修复删除问题（错误：缺少责任人和时间）
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "no-warning-comments": ["warn", {
    "terms": ["todo", "fixme"],
    "location": "start"
  }]
}
```

## 2.6 异常处理与日志

### 规则 2.6.1：前端使用统一的错误处理机制，后端异常必须分类处理
前端统一使用 try-catch 处理异步操作，后端按业务异常、系统异常分类处理。

**正例：**
```typescript
// 前端统一错误处理
const MetricManagementPage: React.FC = () => {
  const [loading, setLoading] = useState(false);
  const { t } = useTranslation();
  
  const handleCreateMetric = async (values: MetricCreateParam) => {
    setLoading(true);
    try {
      const result = await metricService.create(values);
      message.success(t('metric.create.success'));
      return result;
    } catch (error) {
      // 统一错误处理
      if (error.code === 'METRIC_CODE_EXISTS') {
        message.error(t('metric.code.exists'));
      } else if (error.code === 'PERMISSION_DENIED') {
        message.error(t('common.permission.denied'));
      } else {
        message.error(t('common.error.unknown'));
        console.error('创建指标失败:', error);
      }
      throw error;
    } finally {
      setLoading(false);
    }
  };
};
```

```java
// 后端分类异常处理
@Service
public class MetricDefinitionServiceImpl extends BaseService {
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public MetricDefinitionDto create(MetricDefinitionCreateParam createParam) {
        try {
            // 参数验证
            validateCreateParam(createParam);
            
            // 业务逻辑
            MetricDefinition metricDefinition = buildMetricDefinition(createParam);
            int result = metricDefinitionMapper.insert(metricDefinition);
            
            if (result <= 0) {
                throw new BusinessException("METRIC_CREATE_FAILED", "指标创建失败");
            }
            
            return entityToDto(metricDefinition);
            
        } catch (BusinessException e) {
            // 业务异常直接抛出
            log.warn("创建指标业务异常: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            // 系统异常包装后抛出
            log.error("创建指标系统异常", e);
            throw new SystemException("METRIC_CREATE_ERROR", "系统错误，请稍后重试", e);
        }
    }
    
    private void validateCreateParam(MetricDefinitionCreateParam param) {
        if (param == null) {
            throw new BusinessException("PARAM_NULL", "参数不能为空");
        }
        if (!StringUtils.hasText(param.getName())) {
            throw new BusinessException("METRIC_NAME_EMPTY", "指标名称不能为空");
        }
        if (checkCodeExists(param.getOrgId(), param.getCode(), null)) {
            throw new BusinessException("METRIC_CODE_EXISTS", "指标编码已存在");
        }
    }
}
```

**反例：**
```typescript
// 前端错误处理不统一（错误）
const handleCreateMetric = async (values: MetricCreateParam) => {
  metricService.create(values)
    .then(result => {
      message.success('创建成功');
    })
    .catch(error => {
      alert('创建失败'); // 不应使用 alert
    });
};
```

```java
// 后端异常处理不规范（错误）
public MetricDefinitionDto create(MetricDefinitionCreateParam createParam) {
    try {
        // 业务逻辑
        return result;
    } catch (Exception e) {
        e.printStackTrace(); // 不应直接打印堆栈
        return null;         // 不应返回 null
    }
}
```

**自动校验配置：**
```javascript
// .eslintrc.js - 前端
rules: {
  "prefer-promise-reject-errors": "error",
  "no-throw-literal": "error"
}
```

```xml
<!-- checkstyle.xml - 后端 -->
<module name="IllegalCatch">
    <property name="illegalClassNames" value="java.lang.Exception"/>
</module>
```

### 规则 2.6.2：日志级别使用规范，生产环境禁用 console.log
前端生产环境禁用 console，后端按 ERROR/WARN/INFO/DEBUG 分级记录。

**正例：**
```typescript
// 前端日志规范
import { logger } from 'app/utils/logger';

const MetricService = {
  async create(param: MetricCreateParam): Promise<MetricDefinitionDto> {
    logger.info('开始创建指标', { param });
    
    try {
      const result = await this.http.post('/metrics', param);
      logger.info('指标创建成功', { id: result.id, name: result.name });
      return result;
    } catch (error) {
      logger.error('指标创建失败', { error, param });
      throw error;
    }
  }
};
```

```java
// 后端日志规范
@Slf4j
@Service
public class MetricDefinitionServiceImpl {
    
    public MetricDefinitionDto create(MetricDefinitionCreateParam createParam) {
        log.info("开始创建指标定义, orgId: {}, name: {}", 
                createParam.getOrgId(), createParam.getName());
        
        try {
            MetricDefinition result = doCreate(createParam);
            log.info("指标定义创建成功, id: {}, code: {}", 
                    result.getId(), result.getCode());
            return entityToDto(result);
        } catch (BusinessException e) {
            log.warn("指标定义创建业务异常: {}, param: {}", e.getMessage(), createParam);
            throw e;
        } catch (Exception e) {
            log.error("指标定义创建系统异常, param: {}", createParam, e);
            throw new SystemException("系统错误", e);
        }
    }
}
```

**反例：**
```typescript
// 前端日志不规范（错误）
const create = async (param) => {
  console.log('创建指标', param);        // 生产环境会暴露敏感信息
  console.error('创建失败', error);      // 应使用统一日志工具
};
```

```java
// 后端日志不规范（错误）
public void create() {
    System.out.println("创建指标");       // 不应使用 System.out
    log.debug("重要业务信息");            // 重要信息不应使用 debug 级别
}
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "no-console": process.env.NODE_ENV === "production" ? "error" : "warn"
}
```

### 规则 2.6.3：敏感信息不得记录到日志中
密码、token、身份证号等敏感信息严禁记录到日志。

**正例：**
```typescript
// 前端敏感信息处理
const loginUser = async (credentials: LoginCredentials) => {
  logger.info('用户登录', { 
    username: credentials.username,
    // password: credentials.password,  // 密码不记录
    timestamp: Date.now()
  });
};
```

```java
// 后端敏感信息处理
public void login(UserLoginParam param) {
    log.info("用户登录, username: {}", param.getUsername());
    // 不记录密码: log.info("password: {}", param.getPassword());
}
```

**自动校验配置：**
```bash
# 检查敏感信息的脚本
grep -r "password\|token\|secret" --include="*.java" --include="*.ts" src/ | grep -i log
```

## 2.7 单元测试与集成测试

### 规则 2.7.1：单元测试覆盖率不低于 90%，核心业务逻辑必须 100% 覆盖
所有业务逻辑代码必须编写单元测试，覆盖率要求不低于 90%。

**正例：**
```typescript
// 前端单元测试
describe('MetricDefinitionService', () => {
  let service: MetricDefinitionService;
  let mockHttp: jest.Mocked<HttpClient>;

  beforeEach(() => {
    mockHttp = {
      post: jest.fn(),
      get: jest.fn(),
      put: jest.fn(),
      delete: jest.fn(),
    } as any;
    service = new MetricDefinitionService(mockHttp);
  });

  describe('create', () => {
    it('应该成功创建指标定义', async () => {
      // Arrange
      const createParam: MetricCreateParam = {
        name: '用户数',
        code: 'USER_COUNT',
        expression: 'COUNT(DISTINCT user_id)',
        orgId: 'org-1'
      };
      const expectedResult: MetricDefinitionDto = {
        id: 'metric-1',
        ...createParam,
        status: 'DRAFT'
      };
      mockHttp.post.mockResolvedValue(expectedResult);

      // Act
      const result = await service.create(createParam);

      // Assert
      expect(mockHttp.post).toHaveBeenCalledWith('/metrics', createParam);
      expect(result).toEqual(expectedResult);
    });

    it('当指标编码已存在时应该抛出异常', async () => {
      // Arrange
      const createParam: MetricCreateParam = {
        name: '用户数',
        code: 'EXISTING_CODE',
        expression: 'COUNT(*)',
        orgId: 'org-1'
      };
      mockHttp.post.mockRejectedValue(new BusinessException('METRIC_CODE_EXISTS'));

      // Act & Assert
      await expect(service.create(createParam)).rejects.toThrow('METRIC_CODE_EXISTS');
    });
  });
});
```

```java
// 后端单元测试
@ExtendWith(MockitoExtension.class)
class MetricDefinitionServiceImplTest {

    @Mock
    private MetricDefinitionMapperExt metricDefinitionMapper;
    
    @Mock
    private UserMapperExt userMapper;
    
    @InjectMocks
    private MetricDefinitionServiceImpl metricDefinitionService;

    @Test
    @DisplayName("创建指标定义 - 成功场景")
    void create_Success() {
        // Given
        MetricDefinitionCreateParam createParam = MetricDefinitionCreateParam.builder()
                .name("用户数")
                .code("USER_COUNT")
                .expression("COUNT(DISTINCT user_id)")
                .orgId("org-1")
                .build();
        
        when(metricDefinitionMapper.selectByOrgIdAndCode(anyString(), anyString()))
                .thenReturn(null);
        when(metricDefinitionMapper.insert(any(MetricDefinition.class)))
                .thenReturn(1);

        // When
        MetricDefinitionDto result = metricDefinitionService.create(createParam);

        // Then
        assertThat(result).isNotNull();
        assertThat(result.getName()).isEqualTo("用户数");
        assertThat(result.getCode()).isEqualTo("USER_COUNT");
        assertThat(result.getStatus()).isEqualTo("DRAFT");
        
        verify(metricDefinitionMapper).insert(any(MetricDefinition.class));
    }

    @Test
    @DisplayName("创建指标定义 - 编码已存在")
    void create_CodeExists_ThrowsException() {
        // Given
        MetricDefinitionCreateParam createParam = MetricDefinitionCreateParam.builder()
                .name("用户数")
                .code("EXISTING_CODE")
                .orgId("org-1")
                .build();
        
        MetricDefinition existingMetric = new MetricDefinition();
        existingMetric.setCode("EXISTING_CODE");
        when(metricDefinitionMapper.selectByOrgIdAndCode("org-1", "EXISTING_CODE"))
                .thenReturn(existingMetric);

        // When & Then
        assertThatThrownBy(() -> metricDefinitionService.create(createParam))
                .isInstanceOf(BusinessException.class)
                .hasMessageContaining("METRIC_CODE_EXISTS");
    }
}
```

**反例：**
```typescript
// 测试不充分（错误）
describe('MetricService', () => {
  it('should work', () => {
    expect(true).toBe(true); // 无意义的测试
  });
});
```

**自动校验配置：**
```json
// jest.config.js
{
  "coverageThreshold": {
    "global": {
      "branches": 90,
      "functions": 90,
      "lines": 90,
      "statements": 90
    }
  },
  "collectCoverageFrom": [
    "src/**/*.{js,jsx,ts,tsx}",
    "!src/**/*.d.ts",
    "!src/**/index.ts"
  ]
}
```

### 规则 2.7.2：测试文件命名规范，测试用例描述必须清晰
测试文件以 .test.ts/.spec.ts 结尾，测试用例使用中文描述。

**正例：**
```typescript
// MetricDefinitionService.test.ts
describe('MetricDefinitionService 指标定义服务', () => {
  describe('create 创建指标', () => {
    it('当参数正确时应该成功创建指标定义', async () => {});
    it('当指标编码已存在时应该抛出业务异常', async () => {});
    it('当参数为空时应该抛出参数异常', async () => {});
  });
  
  describe('update 更新指标', () => {
    it('当指标存在且有权限时应该成功更新', async () => {});
    it('当指标不存在时应该抛出未找到异常', async () => {});
    it('当无权限时应该抛出权限异常', async () => {});
  });
});
```

```java
// MetricDefinitionServiceImplTest.java
@DisplayName("指标定义服务测试")
class MetricDefinitionServiceImplTest {
    
    @Nested
    @DisplayName("创建指标定义")
    class CreateMetricDefinition {
        
        @Test
        @DisplayName("当参数正确时应该成功创建指标定义")
        void create_ValidParam_Success() {}
        
        @Test
        @DisplayName("当指标编码已存在时应该抛出业务异常")
        void create_CodeExists_ThrowsBusinessException() {}
    }
}
```

**反例：**
```typescript
// 命名和描述不规范（错误）
// metric.test.ts                    // 文件名应该更具体
describe('test', () => {             // 描述不清晰
  it('works', () => {});             // 用例描述不明确
  it('test create function', () => {}); // 应使用中文描述
});
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "jest/valid-describe-callback": "error",
  "jest/valid-title": ["error", {
    "mustMatch": {
      "describe": "^[\\u4e00-\\u9fa5].*$", // 中文开头
      "it": "^(当|应该|能够).*$"
    }
  }]
}
```

### 规则 2.7.3：集成测试使用真实数据库，测试数据必须隔离
集成测试使用独立的测试数据库，每个测试用例数据隔离。

**正例：**
```java
// 集成测试配置
@SpringBootTest
@Transactional
@Rollback
@TestPropertySource(locations = "classpath:application-test.yml")
class MetricDefinitionControllerIntegrationTest {

    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private MetricDefinitionMapper metricDefinitionMapper;
    
    @BeforeEach
    void setUp() {
        // 清理测试数据
        metricDefinitionMapper.deleteAll();
        
        // 准备测试数据
        prepareTestData();
    }
    
    @Test
    @DisplayName("创建指标定义接口集成测试")
    void createMetricDefinition_Integration() {
        // Given
        MetricDefinitionCreateParam param = MetricDefinitionCreateParam.builder()
                .name("集成测试指标")
                .code("INTEGRATION_TEST")
                .expression("COUNT(*)")
                .orgId("test-org")
                .build();
        
        // When
        ResponseEntity<ResponseData<MetricDefinitionDto>> response = 
                restTemplate.postForEntity("/api/v1/metrics", param, 
                        new ParameterizedTypeReference<ResponseData<MetricDefinitionDto>>() {});
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody().isSuccess()).isTrue();
        
        // 验证数据库状态
        List<MetricDefinition> metrics = metricDefinitionMapper.selectByOrgId("test-org");
        assertThat(metrics).hasSize(1);
        assertThat(metrics.get(0).getCode()).isEqualTo("INTEGRATION_TEST");
    }
}
```

**自动校验配置：**
```yaml
# application-test.yml
spring:
  datasource:
    url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  jpa:
    hibernate:
      ddl-auto: create-drop
```

## 2.8 Git 提交信息

### 规则 2.8.1：提交信息使用约定式提交格式
所有提交必须遵循 Conventional Commits 规范。

**正例：**
```bash
# 功能提交
feat(metric): 添加指标定义创建功能

- 实现指标定义的创建接口
- 添加指标编码唯一性校验
- 完善指标表达式验证逻辑

Closes #123

# 修复提交
fix(metric): 修复指标删除时的权限检查问题

修复了删除指标时未正确检查用户权限的问题，现在只有指标创建者
和组织管理员可以删除指标。

Fixes #456

# 文档提交
docs(api): 更新指标管理API文档

- 添加创建指标接口文档
- 完善错误码说明
- 更新接口示例

# 重构提交
refactor(service): 重构指标定义服务层代码

将指标定义服务的业务逻辑进行重构，提高代码可读性和可维护性，
没有改变对外接口。
```

**反例：**
```bash
# 提交信息不规范（错误）
update code                    # 描述不清晰
fix bug                       # 没有说明修复了什么bug
add new feature               # 没有说明具体功能
修复了一个问题                  # 应使用英文格式
feat: add metric function.    # 句号多余
```

**自动校验配置：**
```javascript
// commitlint.config.js
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [2, 'always', [
      'feat', 'fix', 'docs', 'style', 'refactor', 
      'perf', 'test', 'chore', 'revert'
    ]],
    'subject-max-length': [2, 'always', 50],
    'body-max-line-length': [2, 'always', 72]
  }
};
```

### 规则 2.8.2：每次提交只包含一个逻辑变更，提交粒度要合适
每个提交应该是一个完整的、可独立理解的变更。

**正例：**
```bash
# 单一职责的提交
git commit -m "feat(metric): 添加指标编码唯一性校验"
git commit -m "test(metric): 添加指标创建功能的单元测试"
git commit -m "docs(metric): 更新指标管理接口文档"
```

**反例：**
```bash
# 包含多个不相关变更（错误）
git commit -m "feat: 添加指标功能，修复用户登录bug，更新文档"

# 提交粒度过细（错误）
git commit -m "fix: 修复变量名拼写错误"
git commit -m "fix: 调整代码缩进"
git commit -m "fix: 删除多余空行"
```

### 规则 2.8.3：分支命名规范，使用 feature/fix/hotfix 前缀
分支名称必须使用规范前缀，并包含简短描述。

**正例：**
```bash
# 功能分支
feature/metric-definition-management
feature/user-permission-control
feature/dashboard-export

# 修复分支
fix/metric-delete-permission-check
fix/login-session-timeout

# 热修复分支
hotfix/security-vulnerability-fix
hotfix/data-loss-prevention
```

**反例：**
```bash
# 分支命名不规范（错误）
dev                           # 描述不清晰
zhangsan-dev                  # 不应使用个人名称
metric_management             # 应使用短横线
fix-bug                       # 描述不具体
```

**自动校验配置：**
```bash
# .git/hooks/pre-push
#!/bin/sh
branch=$(git rev-parse --abbrev-ref HEAD)
valid_pattern="^(feature|fix|hotfix|release)\/[a-z0-9-]+$"

if [[ ! $branch =~ $valid_pattern ]]; then
  echo "分支名称不符合规范: $branch"
  echo "请使用格式: feature/description 或 fix/description"
  exit 1
fi
```

## 2.9 Lint/Checkstyle/Spotless 配置

### 规则 2.9.1：前端使用 ESLint + Prettier + Stylelint 组合
前端代码质量检查使用统一的 Lint 工具链。

**正例：**
```javascript
// .eslintrc.js
module.exports = {
  extends: [
    'react-app',
    'react-app/jest',
    '@typescript-eslint/recommended',
    'prettier'
  ],
  plugins: ['prettier', 'jsdoc', '@typescript-eslint'],
  rules: {
    'prettier/prettier': ['error'],
    '@typescript-eslint/no-unused-vars': ['error'],
    '@typescript-eslint/explicit-function-return-type': ['warn'],
    'jsdoc/require-jsdoc': ['error', {
      require: {
        FunctionDeclaration: true,
        MethodDefinition: true,
        ClassDeclaration: true
      }
    }],
    'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'warn',
    'prefer-const': 'error',
    'no-var': 'error'
  },
  parserOptions: {
    ecmaVersion: 2020,
    sourceType: 'module',
    ecmaFeatures: {
      jsx: true
    },
    project: './tsconfig.json'
  }
};
```

```json
// .prettierrc
{
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "semi": true,
  "singleQuote": true,
  "trailingComma": "all",
  "arrowParens": "avoid",
  "endOfLine": "auto",
  "bracketSpacing": true,
  "jsxBracketSameLine": false
}
```

```javascript
// stylelint.config.js
module.exports = {
  extends: [
    'stylelint-config-standard',
    'stylelint-config-prettier',
    'stylelint-config-recess-order'
  ],
  plugins: [
    'stylelint-config-styled-components'
  ],
  rules: {
    'indentation': 2,
    'string-quotes': 'single',
    'no-duplicate-selectors': true,
    'color-hex-case': 'lower',
    'color-hex-length': 'short',
    'selector-max-id': 0,
    'selector-combinator-space-after': 'always',
    'selector-attribute-quotes': 'always',
    'declaration-colon-space-after': 'always',
    'declaration-colon-space-before': 'never',
    'block-opening-brace-space-before': 'always',
    'rule-empty-line-before': ['always', {
      except: ['first-nested'],
      ignore: ['after-comment']
    }]
  }
};
```

**自动校验配置：**
```json
// package.json
{
  "scripts": {
    "lint": "eslint --ext .js,.jsx,.ts,.tsx src/",
    "lint:fix": "eslint --ext .js,.jsx,.ts,.tsx src/ --fix",
    "lint:css": "stylelint \"src/**/*.css\"",
    "lint:style": "stylelint \"src/**/*.{js,ts,jsx,tsx}\"",
    "format": "prettier --write \"src/**/*.{js,jsx,ts,tsx,json,css,md}\"",
    "type-check": "tsc --noEmit"
  },
  "lint-staged": {
    "*.{js,jsx,ts,tsx}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{css,scss}": [
      "stylelint --fix",
      "prettier --write"
    ]
  }
}
```

### 规则 2.9.2：后端使用 Checkstyle + SpotBugs + PMD 组合
后端代码质量检查使用 Maven 插件集成。

**正例：**
```xml
<!-- pom.xml -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-checkstyle-plugin</artifactId>
    <version>3.1.2</version>
    <configuration>
        <configLocation>checkstyle.xml</configLocation>
        <encoding>UTF-8</encoding>
        <consoleOutput>true</consoleOutput>
        <failsOnError>true</failsOnError>
        <includeTestSourceDirectory>true</includeTestSourceDirectory>
    </configuration>
    <executions>
        <execution>
            <id>validate</id>
            <phase>validate</phase>
            <goals>
                <goal>check</goal>
            </goals>
        </execution>
    </executions>
</plugin>

<plugin>
    <groupId>com.github.spotbugs</groupId>
    <artifactId>spotbugs-maven-plugin</artifactId>
    <version>4.7.3.0</version>
    <configuration>
        <effort>Max</effort>
        <threshold>Low</threshold>
        <xmlOutput>true</xmlOutput>
    </configuration>
    <executions>
        <execution>
            <goals>
                <goal>check</goal>
            </goals>
        </execution>
    </executions>
</plugin>

<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-pmd-plugin</artifactId>
    <version>3.17.0</version>
    <configuration>
        <rulesets>
            <ruleset>/category/java/bestpractices.xml</ruleset>
            <ruleset>/category/java/codestyle.xml</ruleset>
            <ruleset>/category/java/design.xml</ruleset>
            <ruleset>/category/java/errorprone.xml</ruleset>
            <ruleset>/category/java/performance.xml</ruleset>
        </rulesets>
        <printFailingErrors>true</printFailingErrors>
    </configuration>
    <executions>
        <execution>
            <goals>
                <goal>check</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

```xml
<!-- checkstyle.xml -->
<?xml version="1.0"?>
<!DOCTYPE module PUBLIC
    "-//Checkstyle//DTD Checkstyle Configuration 1.3//EN"
    "https://checkstyle.org/dtds/configuration_1_3.dtd">

<module name="Checker">
    <property name="charset" value="UTF-8"/>
    <property name="severity" value="warning"/>
    <property name="fileExtensions" value="java, properties, xml"/>

    <module name="LineLength">
        <property name="max" value="120"/>
        <property name="ignorePattern" value="^package.*|^import.*|a href|href|http://|https://|ftp://"/>
    </module>

    <module name="TreeWalker">
        <module name="OuterTypeFilename"/>
        <module name="IllegalTokenText">
            <property name="tokens" value="STRING_LITERAL, CHAR_LITERAL"/>
            <property name="format" value="\\u00(09|0(a|A)|0(c|C)|0(d|D)|22|27|5(C|c))|\\(0(10|11|12|14|15|42|47)|134)"/>
            <property name="message" value="Consider using special escape sequence instead of octal value or Unicode escaped value."/>
        </module>
        
        <!-- 命名约定 -->
        <module name="PackageName">
            <property name="format" value="^[a-z]+(\.[a-z][a-z0-9]*)*$"/>
        </module>
        <module name="TypeName">
            <property name="format" value="^[A-Z][a-zA-Z0-9]*$"/>
        </module>
        <module name="MemberName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        <module name="MethodName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        <module name="LocalVariableName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        <module name="ConstantName">
            <property name="format" value="^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"/>
        </module>
        
        <!-- 代码格式 -->
        <module name="Indentation">
            <property name="basicOffset" value="4"/>
            <property name="braceAdjustment" value="0"/>
            <property name="caseIndent" value="4"/>
        </module>
        <module name="LeftCurly"/>
        <module name="RightCurly"/>
        <module name="WhitespaceAround"/>
        <module name="WhitespaceAfter"/>
        
        <!-- 代码质量 -->
        <module name="EmptyBlock"/>
        <module name="NeedBraces"/>
        <module name="AvoidNestedBlocks"/>
        <module name="MissingSwitchDefault"/>
        <module name="FallThrough"/>
        <module name="UpperEll"/>
        <module name="ModifierOrder"/>
        <module name="EmptyLineSeparator">
            <property name="allowNoEmptyLineBetweenFields" value="true"/>
        </module>
        <module name="SeparatorWrap">
            <property name="id" value="SeparatorWrapDot"/>
            <property name="tokens" value="DOT"/>
            <property name="option" value="nl"/>
        </module>
    </module>
</module>
```

### 规则 2.9.3：CI/CD 流水线集成代码检查，检查失败阻止合并
所有代码检查工具必须集成到 CI/CD 流水线中。

**正例：**
```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  frontend-check:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '16'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
    
    - name: Install dependencies
      run: |
        cd frontend
        npm ci
    
    - name: Type check
      run: |
        cd frontend
        npm run type-check
    
    - name: Lint check
      run: |
        cd frontend
        npm run lint
    
    - name: Style check
      run: |
        cd frontend
        npm run lint:css
        npm run lint:style
    
    - name: Run tests
      run: |
        cd frontend
        npm run test:ci

  backend-check:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup JDK 8
      uses: actions/setup-java@v3
      with:
        java-version: '8'
        distribution: 'temurin'
    
    - name: Cache Maven packages
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
    
    - name: Run Checkstyle
      run: mvn checkstyle:check
    
    - name: Run SpotBugs
      run: mvn spotbugs:check
    
    - name: Run PMD
      run: mvn pmd:check
    
    - name: Run tests
      run: mvn test
```

**自动校验配置：**
```bash
# pre-commit hook
#!/bin/sh
echo "运行代码检查..."

# 前端检查
cd frontend
npm run lint || exit 1
npm run type-check || exit 1

# 后端检查
cd ../
mvn checkstyle:check || exit 1
mvn spotbugs:check || exit 1

echo "代码检查通过"
```

## 2.10 依赖与版本管理

### 规则 2.10.1：前端依赖版本锁定，使用 package-lock.json
前端项目必须提交 package-lock.json，确保依赖版本一致性。

**正例：**
```json
// package.json
{
  "name": "datart-frontend",
  "version": "1.0.0",
  "dependencies": {
    "react": "17.0.2",
    "antd": "4.16.13",
    "@types/react": "17.0.38",
    "axios": "^0.21.1",
    "lodash": "^4.17.21"
  },
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^5.0.0",
    "prettier": "^2.2.1",
    "jest": "^27.0.0"
  },
  "engines": {
    "node": "^12.20.0 || ^14.13.1 || >=16.0.0",
    "npm": ">=6.4.1"
  }
}
```

**反例：**
```json
// 版本管理不规范（错误）
{
  "dependencies": {
    "react": "*",           // 不应使用通配符
    "antd": "latest",       // 不应使用 latest
    "axios": "0.21.1"       // 主要依赖应允许小版本更新
  }
}
```

**自动校验配置：**
```bash
# 检查 package-lock.json 是否存在
if [ ! -f "package-lock.json" ]; then
  echo "错误: package-lock.json 文件不存在"
  exit 1
fi

# 检查是否有不安全的版本范围
npm audit --audit-level moderate
```

### 规则 2.10.2：后端依赖统一在父 POM 中管理版本
Maven 项目使用 dependencyManagement 统一管理版本。

**正例：**
```xml
<!-- 父 pom.xml -->
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-dependencies</artifactId>
            <version>2.4.3</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>3.11</version>
        </dependency>
        
        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-starter</artifactId>
            <version>1.2.4</version>
        </dependency>
    </dependencies>
</dependencyManagement>

<!-- 子模块 pom.xml -->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <!-- 版本由父 POM 管理，不需要指定 -->
    </dependency>
    
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-lang3</artifactId>
        <!-- 版本由父 POM 管理 -->
    </dependency>
</dependencies>
```

**反例：**
```xml
<!-- 版本管理不规范（错误） -->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <version>2.4.3</version>  <!-- 应在父 POM 中管理 -->
    </dependency>
    
    <dependency>
        <groupId>commons-lang</groupId>
        <artifactId>commons-lang</artifactId>
        <version>LATEST</version>  <!-- 不应使用 LATEST -->
    </dependency>
</dependencies>
```

**自动校验配置：**
```xml
<!-- maven-enforcer-plugin -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-enforcer-plugin</artifactId>
    <version>3.0.0</version>
    <executions>
        <execution>
            <id>enforce-versions</id>
            <goals>
                <goal>enforce</goal>
            </goals>
            <configuration>
                <rules>
                    <requireMavenVersion>
                        <version>[3.6.0,)</version>
                    </requireMavenVersion>
                    <requireJavaVersion>
                        <version>[1.8,)</version>
                    </requireJavaVersion>
                    <bannedDependencies>
                        <excludes>
                            <exclude>*:*:*:*:LATEST</exclude>
                            <exclude>*:*:*:*:RELEASE</exclude>
                        </excludes>
                    </bannedDependencies>
                </rules>
            </configuration>
        </execution>
    </executions>
</plugin>
```

### 规则 2.10.3：定期更新依赖，及时修复安全漏洞
每月检查依赖更新，及时修复已知安全漏洞。

**正例：**
```bash
# 前端依赖检查脚本
#!/bin/bash
echo "检查前端依赖安全漏洞..."
npm audit

echo "检查过期依赖..."
npm outdated

echo "更新补丁版本..."
npm update

echo "检查许可证合规性..."
npx license-checker --summary
```

```bash
# 后端依赖检查脚本
#!/bin/bash
echo "检查后端依赖安全漏洞..."
mvn org.owasp:dependency-check-maven:check

echo "检查过期依赖..."
mvn versions:display-dependency-updates

echo "更新补丁版本..."
mvn versions:use-latest-releases -DallowSnapshots=false
```

**自动校验配置：**
```yaml
# .github/workflows/security-check.yml
name: Security Check

on:
  schedule:
    - cron: '0 2 * * 1'  # 每周一凌晨2点执行

jobs:
  security-check:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Frontend Security Audit
      run: |
        cd frontend
        npm audit --audit-level moderate
    
    - name: Backend Security Check
      run: |
        mvn org.owasp:dependency-check-maven:check
```

## 2.11 安全与敏感信息

### 规则 2.11.1：敏感信息使用环境变量，不得硬编码
数据库密码、API密钥等敏感信息必须通过环境变量配置。

**正例：**
```typescript
// 前端环境变量配置
// .env.development
REACT_APP_API_BASE_URL=http://localhost:8080/api/v1
REACT_APP_WEBSOCKET_URL=ws://localhost:8080/ws

// .env.production
REACT_APP_API_BASE_URL=https://api.datart.com/v1
REACT_APP_WEBSOCKET_URL=wss://api.datart.com/ws

// 使用环境变量
const config = {
  apiBaseUrl: process.env.REACT_APP_API_BASE_URL || 'http://localhost:8080/api/v1',
  websocketUrl: process.env.REACT_APP_WEBSOCKET_URL || 'ws://localhost:8080/ws',
};
```

```yaml
# 后端环境变量配置
# application.yml
spring:
  datasource:
    url: ${DB_URL:jdbc:mysql://localhost:3306/datart}
    username: ${DB_USERNAME:datart}
    password: ${DB_PASSWORD:}
    
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    password: ${REDIS_PASSWORD:}

datart:
  security:
    jwt-secret: ${JWT_SECRET:}
    encryption-key: ${ENCRYPTION_KEY:}
```

**反例：**
```typescript
// 硬编码敏感信息（错误）
const config = {
  apiBaseUrl: 'https://api.datart.com/v1',
  apiKey: 'sk-1234567890abcdef',        // API密钥不应硬编码
  databasePassword: 'admin123',         // 数据库密码不应硬编码
};
```

```java
// 硬编码敏感信息（错误）
@Component
public class DatabaseConfig {
    private static final String DB_PASSWORD = "admin123";  // 不应硬编码
    private static final String JWT_SECRET = "mySecret";   // 不应硬编码
}
```

**自动校验配置：**
```bash
# 检查敏感信息的脚本
#!/bin/bash
echo "检查硬编码的敏感信息..."

# 检查常见的敏感信息模式
grep -r -i "password.*=" --include="*.ts" --include="*.js" --include="*.java" src/
grep -r -i "secret.*=" --include="*.ts" --include="*.js" --include="*.java" src/
grep -r -i "token.*=" --include="*.ts" --include="*.js" --include="*.java" src/
grep -r -i "key.*=" --include="*.ts" --include="*.js" --include="*.java" src/

if [ $? -eq 0 ]; then
    echo "发现可能的硬编码敏感信息，请检查！"
    exit 1
fi
```

### 规则 2.11.2：输入验证必须在前后端同时进行
所有用户输入必须在前端和后端都进行验证。

**正例：**
```typescript
// 前端输入验证
const MetricDefinitionForm: React.FC = () => {
  const validateMetricCode = (rule: any, value: string) => {
    if (!value) {
      return Promise.reject('指标编码不能为空');
    }
    if (!/^[A-Z][A-Z0-9_]*$/.test(value)) {
      return Promise.reject('指标编码必须以大写字母开头，只能包含大写字母、数字和下划线');
    }
    if (value.length > 50) {
      return Promise.reject('指标编码长度不能超过50个字符');
    }
    return Promise.resolve();
  };

  const validateExpression = (rule: any, value: string) => {
    if (!value) {
      return Promise.reject('指标表达式不能为空');
    }
    // 检查危险的SQL关键字
    const dangerousKeywords = ['DROP', 'DELETE', 'UPDATE', 'INSERT', 'TRUNCATE'];
    const upperValue = value.toUpperCase();
    for (const keyword of dangerousKeywords) {
      if (upperValue.includes(keyword)) {
        return Promise.reject(`表达式不能包含危险关键字: ${keyword}`);
      }
    }
    return Promise.resolve();
  };

  return (
    <Form>
      <Form.Item
        name="code"
        rules={[{ validator: validateMetricCode }]}
      >
        <Input maxLength={50} />
      </Form.Item>
      
      <Form.Item
        name="expression"
        rules={[{ validator: validateExpression }]}
      >
        <Input.TextArea maxLength={1000} />
      </Form.Item>
    </Form>
  );
};
```

```java
// 后端输入验证
@RestController
@Validated
public class MetricDefinitionController {
    
    @PostMapping
    public ResponseData<MetricDefinitionDto> create(
            @Valid @RequestBody MetricDefinitionCreateParam createParam) {
        return ResponseData.success(metricDefinitionService.create(createParam));
    }
}

// 参数验证类
public class MetricDefinitionCreateParam {
    
    @NotBlank(message = "指标名称不能为空")
    @Length(max = 100, message = "指标名称长度不能超过100个字符")
    private String name;
    
    @NotBlank(message = "指标编码不能为空")
    @Pattern(regexp = "^[A-Z][A-Z0-9_]*$", message = "指标编码格式不正确")
    @Length(max = 50, message = "指标编码长度不能超过50个字符")
    private String code;
    
    @NotBlank(message = "指标表达式不能为空")
    @Length(max = 1000, message = "指标表达式长度不能超过1000个字符")
    @ValidExpression  // 自定义验证注解
    private String expression;
}

// 自定义验证注解
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = ExpressionValidator.class)
public @interface ValidExpression {
    String message() default "指标表达式格式不正确";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

// 验证器实现
public class ExpressionValidator implements ConstraintValidator<ValidExpression, String> {
    
    private static final String[] DANGEROUS_KEYWORDS = {
        "DROP", "DELETE", "UPDATE", "INSERT", "TRUNCATE", "ALTER", "CREATE"
    };
    
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (StringUtils.isEmpty(value)) {
            return true; // 空值由 @NotBlank 处理
        }
        
        String upperValue = value.toUpperCase();
        for (String keyword : DANGEROUS_KEYWORDS) {
            if (upperValue.contains(keyword)) {
                context.disableDefaultConstraintViolation();
                context.buildConstraintViolationWithTemplate(
                    "表达式不能包含危险关键字: " + keyword)
                    .addConstraintViolation();
                return false;
            }
        }
        
        return true;
    }
}
```

**反例：**
```typescript
// 前端验证不充分（错误）
const handleSubmit = (values: any) => {
  // 直接提交，没有验证
  metricService.create(values);
};
```

```java
// 后端缺少验证（错误）
@PostMapping
public ResponseData create(@RequestBody MetricDefinitionCreateParam param) {
    // 直接使用参数，没有验证
    return ResponseData.success(service.create(param));
}
```

### 规则 2.11.3：API 接口必须进行权限控制和访问限制
所有 API 接口必须进行身份认证和权限检查。

**正例：**
```java
// 权限控制注解
@RestController
@RequestMapping("/metrics")
@PreAuthorize("hasRole('USER')")
public class MetricDefinitionController {
    
    @PostMapping
    @PreAuthorize("hasPermission(#createParam.orgId, 'ORGANIZATION', 'WRITE')")
    public ResponseData<MetricDefinitionDto> create(
            @Valid @RequestBody MetricDefinitionCreateParam createParam) {
        return ResponseData.success(metricDefinitionService.create(createParam));
    }
    
    @DeleteMapping("/{id}")
    @PreAuthorize("hasPermission(#id, 'METRIC_DEFINITION', 'DELETE')")
    public ResponseData<Boolean> delete(@PathVariable String id) {
        return ResponseData.success(metricDefinitionService.delete(id));
    }
    
    @GetMapping("/org/{orgId}")
    @PreAuthorize("hasPermission(#orgId, 'ORGANIZATION', 'READ')")
    public ResponseData<List<MetricDefinitionDto>> listByOrgId(
            @PathVariable String orgId) {
        return ResponseData.success(metricDefinitionService.listByOrgId(orgId));
    }
}

// 权限检查服务
@Service
public class PermissionService {
    
    public boolean hasPermission(String resourceId, String resourceType, String permission) {
        User currentUser = getCurrentUser();
        if (currentUser == null) {
            return false;
        }
        
        // 检查用户是否有对应资源的权限
        return checkUserPermission(currentUser.getId(), resourceId, resourceType, permission);
    }
    
    private boolean checkUserPermission(String userId, String resourceId, 
                                      String resourceType, String permission) {
        // 实现具体的权限检查逻辑
        return permissionMapper.checkPermission(userId, resourceId, resourceType, permission);
    }
}
```

**自动校验配置：**
```java
// 安全配置
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/api/v1/auth/**").permitAll()
                .antMatchers("/api/v1/public/**").permitAll()
                .anyRequest().authenticated()
            .and()
            .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .addFilterBefore(jwtAuthenticationFilter(), 
                           UsernamePasswordAuthenticationFilter.class);
    }
}
```

## 2.12 CI/CD 卡点脚本

### 规则 2.12.1：代码提交前必须通过所有检查
提交代码前必须通过 lint、test、build 等所有检查。

**正例：**
```bash
#!/bin/bash
# pre-commit.sh - Git pre-commit hook

set -e

echo "🔍 开始代码检查..."

# 检查暂存的文件
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(ts|tsx|js|jsx)$' || true)

if [ -z "$STAGED_FILES" ]; then
    echo "✅ 没有需要检查的前端文件"
    exit 0
fi

echo "📁 检查的文件:"
echo "$STAGED_FILES"

# 进入前端目录
cd frontend

# 1. TypeScript 类型检查
echo "🔧 TypeScript 类型检查..."
npm run type-check
if [ $? -ne 0 ]; then
    echo "❌ TypeScript 类型检查失败"
    exit 1
fi

# 2. ESLint 检查
echo "🔍 ESLint 检查..."
echo "$STAGED_FILES" | xargs npm run lint --
if [ $? -ne 0 ]; then
    echo "❌ ESLint 检查失败"
    exit 1
fi

# 3. Prettier 格式检查
echo "💅 Prettier 格式检查..."
echo "$STAGED_FILES" | xargs npx prettier --check
if [ $? -ne 0 ]; then
    echo "❌ 代码格式不符合规范，请运行 npm run format"
    exit 1
fi

# 4. 单元测试
echo "🧪 运行单元测试..."
npm run test:ci
if [ $? -ne 0 ]; then
    echo "❌ 单元测试失败"
    exit 1
fi

# 返回根目录检查后端
cd ..

# 5. 后端代码检查
echo "☕ 后端代码检查..."
mvn checkstyle:check
if [ $? -ne 0 ]; then
    echo "❌ Checkstyle 检查失败"
    exit 1
fi

mvn spotbugs:check
if [ $? -ne 0 ]; then
    echo "❌ SpotBugs 检查失败"
    exit 1
fi

# 6. 后端单元测试
echo "🧪 后端单元测试..."
mvn test
if [ $? -ne 0 ]; then
    echo "❌ 后端单元测试失败"
    exit 1
fi

echo "✅ 所有检查通过，可以提交代码"
```

**反例：**
```bash
# 不完整的检查脚本（错误）
#!/bin/bash
npm run lint  # 只检查 lint，没有其他检查
git add .     # 直接添加所有文件
```

### 规则 2.12.2：构建流水线必须包含完整的质量门禁
CI/CD 流水线必须包含代码检查、测试、构建、部署等完整环节。

**正例：**
```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  NODE_VERSION: '16'
  JAVA_VERSION: '8'

jobs:
  # 代码质量检查
  quality-check:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # 获取完整历史用于 SonarQube

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Setup JDK
      uses: actions/setup-java@v3
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'

    - name: Cache Maven packages
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}

    # 前端质量检查
    - name: Install frontend dependencies
      run: |
        cd frontend
        npm ci

    - name: Frontend lint check
      run: |
        cd frontend
        npm run lint

    - name: Frontend type check
      run: |
        cd frontend
        npm run type-check

    - name: Frontend test with coverage
      run: |
        cd frontend
        npm run test:coverage

    # 后端质量检查
    - name: Backend code quality check
      run: |
        mvn checkstyle:check
        mvn spotbugs:check
        mvn pmd:check

    - name: Backend test with coverage
      run: mvn test jacoco:report

    # SonarQube 分析
    - name: SonarQube analysis
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      run: |
        mvn sonar:sonar \
          -Dsonar.projectKey=datart \
          -Dsonar.organization=datart-org \
          -Dsonar.host.url=https://sonarcloud.io \
          -Dsonar.login=${{ secrets.SONAR_TOKEN }}

    # 质量门禁检查
    - name: Quality Gate check
      uses: sonarqube-quality-gate-action@master
      timeout-minutes: 5
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  # 构建和部署
  build-and-deploy:
    needs: quality-check
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Setup JDK
      uses: actions/setup-java@v3
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'

    - name: Build frontend
      run: |
        cd frontend
        npm ci
        npm run build

    - name: Build backend
      run: mvn clean package -DskipTests

    - name: Build Docker image
      run: |
        docker build -t datart:${{ github.sha }} .
        docker tag datart:${{ github.sha }} datart:latest

    - name: Deploy to staging
      if: github.ref == 'refs/heads/develop'
      run: |
        echo "部署到测试环境"
        # 部署脚本

    - name: Deploy to production
      if: github.ref == 'refs/heads/main'
      run: |
        echo "部署到生产环境"
        # 部署脚本

  # 安全扫描
  security-scan:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Frontend security audit
      run: |
        cd frontend
        npm audit --audit-level moderate

    - name: Backend security scan
      run: mvn org.owasp:dependency-check-maven:check

    - name: Container security scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: 'datart:latest'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif'
```

### 规则 2.12.3：部署前必须进行自动化测试验证
生产部署前必须通过完整的自动化测试套件。

**正例：**
```bash
#!/bin/bash
# deploy-validation.sh - 部署验证脚本

set -e

APP_URL=${1:-"http://localhost:8080"}
TIMEOUT=300  # 5分钟超时

echo "🚀 开始部署验证..."
echo "📍 应用地址: $APP_URL"

# 1. 健康检查
echo "🏥 应用健康检查..."
for i in {1..30}; do
    if curl -f "$APP_URL/actuator/health" > /dev/null 2>&1; then
        echo "✅ 应用启动成功"
        break
    fi
    echo "⏳ 等待应用启动... ($i/30)"
    sleep 10
done

# 2. API 接口测试
echo "🔌 API 接口测试..."
# 测试登录接口
LOGIN_RESPONSE=$(curl -s -X POST "$APP_URL/api/v1/auth/login" \
    -H "Content-Type: application/json" \
    -d '{"username":"admin","password":"admin123"}')

if echo "$LOGIN_RESPONSE" | grep -q "token"; then
    echo "✅ 登录接口正常"
    TOKEN=$(echo "$LOGIN_RESPONSE" | jq -r '.data.token')
else
    echo "❌ 登录接口异常"
    exit 1
fi

# 测试指标管理接口
METRICS_RESPONSE=$(curl -s -X GET "$APP_URL/api/v1/metrics/org/default" \
    -H "Authorization: Bearer $TOKEN")

if echo "$METRICS_RESPONSE" | grep -q "success"; then
    echo "✅ 指标管理接口正常"
else
    echo "❌ 指标管理接口异常"
    exit 1
fi

# 3. 数据库连接测试
echo "🗄️ 数据库连接测试..."
DB_STATUS=$(curl -s "$APP_URL/actuator/health/db" | jq -r '.status')
if [ "$DB_STATUS" = "UP" ]; then
    echo "✅ 数据库连接正常"
else
    echo "❌ 数据库连接异常"
    exit 1
fi

# 4. 缓存连接测试
echo "💾 缓存连接测试..."
REDIS_STATUS=$(curl -s "$APP_URL/actuator/health/redis" | jq -r '.status')
if [ "$REDIS_STATUS" = "UP" ]; then
    echo "✅ Redis 连接正常"
else
    echo "❌ Redis 连接异常"
    exit 1
fi

# 5. 前端资源检查
echo "🌐 前端资源检查..."
if curl -f "$APP_URL/static/js/main.js" > /dev/null 2>&1; then
    echo "✅ 前端资源加载正常"
else
    echo "❌ 前端资源加载异常"
    exit 1
fi

# 6. 性能基准测试
echo "⚡ 性能基准测试..."
RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' "$APP_URL/api/v1/metrics/org/default" \
    -H "Authorization: Bearer $TOKEN")

if (( $(echo "$RESPONSE_TIME < 2.0" | bc -l) )); then
    echo "✅ API 响应时间正常: ${RESPONSE_TIME}s"
else
    echo "⚠️ API 响应时间较慢: ${RESPONSE_TIME}s"
fi

echo "🎉 部署验证完成，应用运行正常"
```

**自动校验配置：**
```yaml
# deployment-validation.yml
name: Deployment Validation

on:
  deployment_status:

jobs:
  validate-deployment:
    if: github.event.deployment_status.state == 'success'
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Run deployment validation
      run: |
        chmod +x ./scripts/deploy-validation.sh
        ./scripts/deploy-validation.sh ${{ github.event.deployment_status.target_url }}
    
    - name: Notify on failure
      if: failure()
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        text: "部署验证失败，请检查应用状态"
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
```

---

## 一键自检脚本

以下脚本可以在本地验证新生成的代码是否符合本规范：

```bash
#!/bin/bash
# code-style-check.sh - 代码风格一键自检脚本

set -e

echo "🔍 Datart 代码风格规范检查"
echo "================================"

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 检查结果统计
TOTAL_CHECKS=0
PASSED_CHECKS=0
FAILED_CHECKS=0

# 检查函数
check_rule() {
    local rule_name="$1"
    local check_command="$2"
    local description="$3"
    
    TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
    echo -n "检查 $rule_name: $description ... "
    
    if eval "$check_command" > /dev/null 2>&1; then
        echo -e "${GREEN}✅ 通过${NC}"
        PASSED_CHECKS=$((PASSED_CHECKS + 1))
    else
        echo -e "${RED}❌ 失败${NC}"
        FAILED_CHECKS=$((FAILED_CHECKS + 1))
    fi
}

echo "📁 检查目录结构和文件命名..."

# 2.1 目录与文件命名检查
check_rule "2.1.1" "find frontend/src -type d -name '*[A-Z]*' | grep -v '/[A-Z][a-zA-Z]*$'" "前端组件目录使用PascalCase"
check_rule "2.1.2" "find server/src/main/java -name '*.java' | xargs -I {} basename {} .java | grep -E '^[A-Z][a-zA-Z0-9]*$'" "后端类文件使用PascalCase"
check_rule "2.1.3" "ls | grep -E '^[a-z.-]+\.(json|yml|js|xml)$'" "配置文件使用短横线命名"

echo ""
echo "🏗️ 检查模块与包结构..."

# 2.2 模块与包结构检查
check_rule "2.2.1" "find frontend/src -type d | awk -F'/' 'NF > 6 {exit 1}'" "前端目录嵌套不超过4层"
check_rule "2.2.2" "find server/src/main/java -name '*.java' -path '*/controller/*' -exec grep -l '@RestController' {} \;" "后端Controller层结构正确"

echo ""
echo "🏷️ 检查命名规范..."

# 2.3 变量、函数、类、接口命名检查
if [ -d "frontend" ]; then
    check_rule "2.3.1" "grep -r 'const [a-z][a-zA-Z0-9]*' frontend/src --include='*.ts' --include='*.tsx'" "前端变量使用camelCase"
    check_rule "2.3.3" "grep -r 'interface I[A-Z]' frontend/src --include='*.ts' --include='*.tsx'" "前端接口以I开头"
fi

if [ -d "server" ]; then
    check_rule "2.3.2" "grep -r 'public class [A-Z][a-zA-Z0-9]*' server/src --include='*.java'" "后端类名使用PascalCase"
    check_rule "2.3.3" "find server/src -name '*Dto.java' -o -name '*Param.java'" "后端DTO和Param类命名正确"
fi

echo ""
echo "📝 检查代码格式..."

# 2.4 代码格式与缩进检查
if [ -f "frontend/.prettierrc" ]; then
    check_rule "2.4.1" "grep '\"tabWidth\": 2' frontend/.prettierrc" "前端使用2个空格缩进"
    check_rule "2.4.1" "grep '\"printWidth\": 80' frontend/.prettierrc" "前端行宽限制80字符"
fi

if [ -f "checkstyle.xml" ]; then
    check_rule "2.4.2" "grep 'basicOffset.*4' checkstyle.xml" "后端使用4个空格缩进"
    check_rule "2.4.2" "grep 'max.*120' checkstyle.xml" "后端行宽限制120字符"
fi

echo ""
echo "📖 检查注释规范..."

# 2.5 注释与文档注释检查
if [ -d "frontend" ]; then
    check_rule "2.5.1" "grep -r '/\*\*' frontend/src --include='*.ts' --include='*.tsx'" "前端包含JSDoc注释"
fi

if [ -d "server" ]; then
    check_rule "2.5.1" "grep -r '/\*\*' server/src --include='*.java'" "后端包含JavaDoc注释"
fi

echo ""
echo "🛡️ 检查异常处理..."

# 2.6 异常处理与日志检查
if [ -d "frontend" ]; then
    check_rule "2.6.1" "grep -r 'try.*catch' frontend/src --include='*.ts' --include='*.tsx'" "前端使用try-catch处理异常"
fi

if [ -d "server" ]; then
    check_rule "2.6.1" "grep -r '@Slf4j' server/src --include='*.java'" "后端使用Slf4j日志"
    check_rule "2.6.2" "! grep -r 'System.out.println' server/src --include='*.java'" "后端不使用System.out"
fi

echo ""
echo "🧪 检查测试覆盖..."

# 2.7 单元测试与集成测试检查
if [ -d "frontend/src/__tests__" ] || [ -d "frontend/src" ] && find frontend/src -name "*.test.ts" -o -name "*.spec.ts" | head -1; then
    check_rule "2.7.1" "find frontend/src -name '*.test.ts' -o -name '*.spec.ts'" "前端包含测试文件"
fi

if [ -d "server/src/test" ]; then
    check_rule "2.7.1" "find server/src/test -name '*Test.java'" "后端包含测试文件"
fi

echo ""
echo "📋 检查Git提交规范..."

# 2.8 Git提交信息检查
if [ -f ".gitmessage" ] || [ -f "commitlint.config.js" ]; then
    check_rule "2.8.1" "test -f commitlint.config.js" "存在commitlint配置"
fi

echo ""
echo "🔧 检查Lint配置..."

# 2.9 Lint配置检查
if [ -f "frontend/.eslintrc.js" ]; then
    check_rule "2.9.1" "grep 'prettier' frontend/.eslintrc.js" "前端ESLint集成Prettier"
fi

if [ -f "pom.xml" ]; then
    check_rule "2.9.2" "grep 'checkstyle' pom.xml" "后端集成Checkstyle"
fi

echo ""
echo "📦 检查依赖管理..."

# 2.10 依赖与版本管理检查
if [ -f "frontend/package-lock.json" ]; then
    check_rule "2.10.1" "test -f frontend/package-lock.json" "前端存在package-lock.json"
fi

if [ -f "pom.xml" ]; then
    check_rule "2.10.2" "grep 'dependencyManagement' pom.xml" "后端使用dependencyManagement"
fi

echo ""
echo "🔒 检查安全规范..."

# 2.11 安全与敏感信息检查
check_rule "2.11.1" "! grep -r 'password.*=' --include='*.ts' --include='*.js' --include='*.java' . | grep -v test" "代码中无硬编码密码"
check_rule "2.11.1" "! grep -r 'secret.*=' --include='*.ts' --include='*.js' --include='*.java' . | grep -v test" "代码中无硬编码密钥"

echo ""
echo "🚀 检查CI/CD配置..."

# 2.12 CI/CD配置检查
if [ -d ".github/workflows" ]; then
    check_rule "2.12.1" "find .github/workflows -name '*.yml' -o -name '*.yaml'" "存在GitHub Actions配置"
fi

if [ -f ".husky/pre-commit" ]; then
    check_rule "2.12.1" "test -f .husky/pre-commit" "存在pre-commit钩子"
fi

echo ""
echo "================================"
echo "📊 检查结果统计"
echo "================================"
echo -e "总检查项: $TOTAL_CHECKS"
echo -e "${GREEN}通过: $PASSED_CHECKS${NC}"
echo -e "${RED}失败: $FAILED_CHECKS${NC}"

if [ $FAILED_CHECKS -eq 0 ]; then
    echo -e "${GREEN}🎉 恭喜！所有检查都通过了！${NC}"
    echo "您的代码完全符合 Datart 编码规范。"
    exit 0
else
    echo -e "${YELLOW}⚠️ 发现 $FAILED_CHECKS 个不符合规范的项目${NC}"
    echo "请根据上述检查结果修复相关问题。"
    echo ""
    echo "💡 修复建议："
    echo "1. 运行 'npm run lint:fix' 自动修复前端代码格式问题"
    echo "2. 运行 'mvn checkstyle:check' 检查后端代码规范"
    echo "3. 确保所有敏感信息都使用环境变量配置"
    echo "4. 为缺少测试的代码补充单元测试"
    echo "5. 检查并修复命名不规范的文件和变量"
    exit 1
fi
```

**使用方法：**

1. 将脚本保存为 `code-style-check.sh`
2. 在项目根目录执行：
   ```bash
   chmod +x code-style-check.sh
   ./code-style-check.sh
   ```

3. 根据检查结果修复相关问题

**注意事项：**
- 脚本会检查前端和后端的所有规范要求
- 检查失败时会提供具体的修复建议
- 建议在提交代码前运行此脚本进行自检
- 可以将此脚本集成到 Git pre-commit 钩子中

---

**文档版本：** v1.0.0  
**最后更新：** 2024-01-15  
**适用项目：** Datart v1.0.0-rc.3+

本规范文档是 Datart 项目代码质量的重要保障，所有开发者都必须严格遵循。如有疑问或建议，请联系项目维护团队。
