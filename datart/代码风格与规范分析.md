# Datart 项目代码风格和规范

本文档是 datart 项目的官方编码规范，适用于前端（React/TypeScript）和后端（Java/Spring Boot）开发。所有开发者必须严格遵循此规范。

## 2.1 目录与文件命名

### 规则 2.1.1：前端目录使用 camelCase，组件目录使用 PascalCase
前端普通目录使用小驼峰命名，React 组件目录使用大驼峰命名。

**正例：**
```
frontend/src/
├── app/
├── components/
│   ├── ChartGraph/
│   │   └── BasicOutlineMapChart/
│   └── DataTable/
├── pages/
│   └── MainPage/
├── utils/
└── types/
```

**反例：**
```
frontend/src/
├── App/           # 普通目录不应使用大驼峰
├── chart-graph/   # 组件目录不应使用短横线
├── data_table/    # 不应使用下划线
└── Utils/         # 普通目录不应使用大驼峰
```

**自动校验配置：**
```bash
# .eslintrc.js 中添加文件命名规则
rules: {
  "unicorn/filename-case": [
    "error",
    {
      "cases": {
        "camelCase": true,
        "pascalCase": true
      }
    }
  ]
}
```

### 规则 2.1.2：后端包名使用全小写，类文件使用 PascalCase
Java 包名必须全小写，类文件名必须与类名一致使用大驼峰命名。

**正例：**
```
server/src/main/java/datart/server/
├── controller/
│   ├── MetricDefinitionController.java
│   └── UserController.java
├── service/
│   └── impl/
│       └── MetricDefinitionServiceImpl.java
└── base/
    ├── dto/
    └── params/
```

**反例：**
```
server/src/main/java/datart/server/
├── Controller/                    # 包名不应大写
├── Service_Impl/                  # 包名不应使用下划线
├── metricDefinitionController.java # 类文件名应与类名一致
└── metric-controller.java         # 不应使用短横线
```

**自动校验配置：**
```xml
<!-- checkstyle.xml -->
<module name="PackageName">
    <property name="format" value="^[a-z]+(\.[a-z][a-z0-9]*)*$"/>
</module>
<module name="TypeName">
    <property name="format" value="^[A-Z][a-zA-Z0-9]*$"/>
</module>
```

### 规则 2.1.3：配置文件使用短横线命名
所有配置文件统一使用短横线分隔命名。

**正例：**
```
.eslintrc.js
.prettierrc
application.yml
application-dev.yml
tsconfig.json
package.json
```

**反例：**
```
eslint_config.js    # 不应使用下划线
prettier.config.js  # 应使用 .prettierrc
applicationDev.yml  # 不应使用驼峰
```

**自动校验配置：**
```bash
# 在 package.json 的 scripts 中添加
"check-config": "find . -name '*.config.js' -o -name '*_config.*' | grep -v node_modules && exit 1 || exit 0"
```

## 2.2 模块与包结构

### 规则 2.2.1：前端按功能模块组织，最大嵌套深度不超过 4 层
前端代码按业务功能模块组织，目录嵌套深度不得超过 4 层。

**正例：**
```typescript
// src/app/pages/MainPage/pages/MetricPage/index.tsx
export const MetricPage: React.FC = () => {
  return <div>Metric Management</div>;
};

// 目录结构深度：src(1)/app(2)/pages(3)/MainPage(4) ✓
```

**反例：**
```typescript
// src/app/pages/main/components/metric/management/list/item/index.tsx
// 目录结构深度超过 4 层 ✗
```

**自动校验配置：**
```bash
# 检查目录深度的脚本
find src -type d | awk -F'/' 'NF > 6 {print "目录深度超过4层: " $0; exit 1}'
```

### 规则 2.2.2：后端采用分层架构，包结构固定为 controller/service/mapper
后端严格按照 MVC 分层架构组织，包结构层次固定。

**正例：**
```java
// datart.server.controller.MetricDefinitionController
@RestController
@RequestMapping("/metrics")
public class MetricDefinitionController extends BaseController {
    private final MetricDefinitionService metricDefinitionService;
}

// datart.server.service.impl.MetricDefinitionServiceImpl
@Service
public class MetricDefinitionServiceImpl extends BaseService 
    implements MetricDefinitionService {
}
```

**反例：**
```java
// 不应将业务逻辑写在 Controller 中
@RestController
public class MetricController {
    public ResponseData create() {
        // 直接在 Controller 中写业务逻辑 ✗
        MetricDefinition metric = new MetricDefinition();
        // ... 复杂业务逻辑
    }
}
```

**自动校验配置：**
```xml
<!-- maven-checkstyle-plugin 配置 -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-checkstyle-plugin</artifactId>
    <configuration>
        <configLocation>checkstyle.xml</configLocation>
        <includeTestSourceDirectory>true</includeTestSourceDirectory>
    </configuration>
</plugin>
```

### 规则 2.2.3：每个模块的导入语句不超过 20 个
单个文件的 import 语句数量不得超过 20 个，超过则需要重构。

**正例：**
```typescript
// 导入语句控制在合理范围内
import React, { useState, useEffect } from 'react';
import { Button, Table, Modal } from 'antd';
import { useTranslation } from 'react-i18next';
import { MetricDefinitionDto } from 'app/types/MetricDefinition';
import { metricService } from 'app/services/metricService';
// ... 总计不超过 20 个导入
```

**反例：**
```typescript
// 导入过多，需要重构
import React from 'react';
import { useState } from 'react';
import { useEffect } from 'react';
// ... 超过 20 个单独的导入语句 ✗
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "import/max-dependencies": ["error", {"max": 20}]
}
```

## 2.3 变量、函数、类、接口命名

### 规则 2.3.1：前端变量和函数使用 camelCase，常量使用 SCREAMING_SNAKE_CASE
TypeScript/JavaScript 变量和函数使用小驼峰，常量使用全大写下划线。

**正例：**
```typescript
// 变量和函数
const metricDefinition = new MetricDefinition();
const isLoading = false;
const handleSubmit = () => {};
const getUserProfile = async () => {};

// 常量
const API_BASE_URL = 'http://localhost:8080/api/v1';
const MAX_RETRY_COUNT = 3;
const DEFAULT_PAGE_SIZE = 20;
```

**反例：**
```typescript
// 变量命名错误
const MetricDefinition = {};     // 应使用 camelCase
const is_loading = false;        // 不应使用下划线
const HandleSubmit = () => {};   // 函数不应使用 PascalCase

// 常量命名错误
const apiBaseUrl = 'http://...'; // 常量应使用 SCREAMING_SNAKE_CASE
const maxRetryCount = 3;         // 常量应使用 SCREAMING_SNAKE_CASE
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "camelcase": ["error", {
    "properties": "always",
    "ignoreDestructuring": false,
    "ignoreImports": false,
    "ignoreGlobals": false
  }],
  "@typescript-eslint/naming-convention": [
    "error",
    {
      "selector": "variable",
      "format": ["camelCase", "UPPER_CASE"]
    },
    {
      "selector": "function",
      "format": ["camelCase"]
    }
  ]
}
```

### 规则 2.3.2：后端类名使用 PascalCase，方法和变量使用 camelCase
Java 类名使用大驼峰，方法名和变量名使用小驼峰。

**正例：**
```java
// 类名
public class MetricDefinitionController extends BaseController {
    
    // 成员变量
    private final MetricDefinitionService metricDefinitionService;
    
    // 方法名
    public ResponseData<MetricDefinitionDto> create(
        @Valid @RequestBody MetricDefinitionCreateParam createParam) {
        MetricDefinitionDto result = metricDefinitionService.create(createParam);
        return ResponseData.success(result);
    }
    
    // 局部变量
    private void validateMetricCode(String orgId, String code) {
        boolean codeExists = metricDefinitionService.checkCodeExists(orgId, code, null);
        if (codeExists) {
            throw new BusinessException("指标编码已存在");
        }
    }
}
```

**反例：**
```java
// 类名错误
public class metricDefinitionController {  // 应使用 PascalCase
public class Metric_Definition_Service {   // 不应使用下划线

// 方法名错误
public ResponseData Create() {}            // 应使用 camelCase
public void Validate_Code() {}             // 不应使用下划线

// 变量名错误
private String MetricName;                 // 应使用 camelCase
private boolean is_valid;                  // 不应使用下划线
```

**自动校验配置：**
```xml
<!-- checkstyle.xml -->
<module name="MethodName">
    <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
</module>
<module name="MemberName">
    <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
</module>
<module name="LocalVariableName">
    <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
</module>
```

### 规则 2.3.3：接口名以 I 开头，DTO 类以 Dto 结尾，参数类以 Param 结尾
接口、DTO、参数类必须按照固定后缀命名。

**正例：**
```typescript
// 前端接口定义
interface IMetricDefinition {
  id: string;
  name: string;
  code: string;
}

interface IMetricService {
  create(param: MetricCreateParam): Promise<MetricDefinitionDto>;
  update(param: MetricUpdateParam): Promise<MetricDefinitionDto>;
}
```

```java
// 后端类定义
public class MetricDefinitionDto {
    private String id;
    private String name;
    private String code;
}

public class MetricDefinitionCreateParam {
    @NotBlank
    private String name;
    @NotBlank
    private String code;
}
```

**反例：**
```typescript
// 接口命名错误
interface MetricDefinition {}      // 应以 I 开头
interface MetricServiceInterface {} // 不应使用 Interface 后缀
```

```java
// 类命名错误
public class MetricDefinition {}    // DTO 应以 Dto 结尾
public class MetricCreateRequest {} // 参数类应以 Param 结尾
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "@typescript-eslint/naming-convention": [
    "error",
    {
      "selector": "interface",
      "format": ["PascalCase"],
      "prefix": ["I"]
    }
  ]
}
```

## 2.4 代码格式与缩进

### 规则 2.4.1：使用 2 个空格缩进，行宽限制 80 字符
所有代码文件统一使用 2 个空格缩进，单行长度不超过 80 字符。

**正例：**
```typescript
// 2 个空格缩进，行宽 80 字符内
const MetricDefinitionForm: React.FC<IProps> = ({ 
  initialValues, 
  onSubmit 
}) => {
  const [form] = Form.useForm();
  const { t } = useTranslation();
  
  const handleSubmit = async (values: MetricCreateParam) => {
    try {
      await onSubmit(values);
      message.success(t('common.success'));
    } catch (error) {
      message.error(t('common.error'));
    }
  };
  
  return (
    <Form
      form={form}
      layout="vertical"
      initialValues={initialValues}
      onFinish={handleSubmit}
    >
      <Form.Item
        name="name"
        label={t('metric.name')}
        rules={[{ required: true, message: t('metric.name.required') }]}
      >
        <Input placeholder={t('metric.name.placeholder')} />
      </Form.Item>
    </Form>
  );
};
```

**反例：**
```typescript
// 4 个空格缩进（错误）
const MetricDefinitionForm: React.FC<IProps> = ({ initialValues, onSubmit }) => {
    const [form] = Form.useForm();
    
    // 行宽超过 80 字符（错误）
    const handleSubmit = async (values: MetricCreateParam) => {
        try {
            await onSubmit(values);
            message.success('操作成功，指标定义已创建，请查看指标列表确认结果');
        } catch (error) {
            message.error('操作失败，请检查网络连接和输入参数是否正确，然后重试');
        }
    };
};
```

**自动校验配置：**
```json
// .prettierrc
{
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "semi": true,
  "singleQuote": true,
  "trailingComma": "all",
  "arrowParens": "avoid",
  "endOfLine": "auto"
}
```

### 规则 2.4.2：Java 代码使用 4 个空格缩进，行宽限制 120 字符
Java 代码使用 4 个空格缩进，单行长度不超过 120 字符。

**正例：**
```java
@RestController
@RequestMapping("/metrics")
@Validated
public class MetricDefinitionController extends BaseController {

    private final MetricDefinitionService metricDefinitionService;

    public MetricDefinitionController(MetricDefinitionService metricDefinitionService) {
        this.metricDefinitionService = metricDefinitionService;
    }

    @ApiOperation("创建指标定义")
    @PostMapping
    public ResponseData<MetricDefinitionDto> create(
            @Valid @RequestBody MetricDefinitionCreateParam createParam) {
        MetricDefinitionDto result = metricDefinitionService.create(createParam);
        return ResponseData.success(result);
    }

    @ApiOperation("根据状态获取组织下的指标列表")
    @GetMapping("/org/{orgId}/status/{status}")
    public ResponseData<List<MetricDefinitionDto>> listByOrgIdAndStatus(
            @ApiParam("组织ID") @PathVariable @NotBlank String orgId,
            @ApiParam("状态") @PathVariable @NotBlank String status) {
        List<MetricDefinitionDto> result = 
            metricDefinitionService.listByOrgIdAndStatus(orgId, status);
        return ResponseData.success(result);
    }
}
```

**反例：**
```java
// 2 个空格缩进（错误）
@RestController
public class MetricDefinitionController {
  private final MetricDefinitionService service;
  
  // 行宽超过 120 字符（错误）
  public ResponseData<List<MetricDefinitionDto>> listByOrgIdAndStatus(@PathVariable String orgId, @PathVariable String status) {
    return ResponseData.success(metricDefinitionService.listByOrgIdAndStatus(orgId, status));
  }
}
```

**自动校验配置：**
```xml
<!-- checkstyle.xml -->
<module name="Indentation">
    <property name="basicOffset" value="4"/>
    <property name="braceAdjustment" value="0"/>
    <property name="caseIndent" value="4"/>
</module>
<module name="LineLength">
    <property name="max" value="120"/>
    <property name="ignorePattern" value="^package.*|^import.*|a href|href|http://|https://|ftp://"/>
</module>
```

### 规则 2.4.3：大括号使用 K&R 风格，左大括号不换行
所有语言统一使用 K&R 大括号风格。

**正例：**
```typescript
// TypeScript K&R 风格
if (condition) {
  doSomething();
} else {
  doSomethingElse();
}

const obj = {
  name: 'metric',
  code: 'M001',
};

function handleSubmit() {
  if (isValid) {
    submit();
  }
}
```

```java
// Java K&R 风格
if (condition) {
    doSomething();
} else {
    doSomethingElse();
}

public void create() {
    if (isValid()) {
        save();
    }
}
```

**反例：**
```typescript
// Allman 风格（错误）
if (condition) 
{
  doSomething();
}

// GNU 风格（错误）
if (condition)
  {
    doSomething();
  }
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "brace-style": ["error", "1tbs", { "allowSingleLine": true }]
}
```

## 2.5 注释与文档注释

### 规则 2.5.1：所有公共 API 必须有 JSDoc/JavaDoc 注释
公共接口、类、方法必须提供完整的文档注释。

**正例：**
```typescript
/**
 * 指标定义服务
 * 提供指标的创建、更新、删除、查询等功能
 */
export class MetricDefinitionService {
  
  /**
   * 创建指标定义
   * @param param 创建参数
   * @param param.name 指标名称，必填，长度1-50字符
   * @param param.code 指标编码，必填，组织内唯一
   * @param param.expression 指标表达式，必填
   * @returns Promise<MetricDefinitionDto> 创建成功的指标信息
   * @throws {BusinessException} 当指标编码已存在时抛出异常
   * @example
   * ```typescript
   * const result = await metricService.create({
   *   name: '用户数',
   *   code: 'USER_COUNT',
   *   expression: 'COUNT(DISTINCT user_id)'
   * });
   * ```
   */
  async create(param: MetricCreateParam): Promise<MetricDefinitionDto> {
    return this.http.post('/metrics', param);
  }
}
```

```java
/**
 * 指标定义控制器
 * 提供指标定义的 REST API 接口
 * 
 * @author datart-team
 * @since 1.0.0
 */
@RestController
@RequestMapping("/metrics")
public class MetricDefinitionController extends BaseController {

    /**
     * 创建指标定义
     * 
     * @param createParam 创建参数，包含指标名称、编码、表达式等信息
     * @return ResponseData<MetricDefinitionDto> 包装的响应数据，包含创建成功的指标信息
     * @throws BusinessException 当指标编码已存在或参数验证失败时抛出
     * @see MetricDefinitionCreateParam
     * @see MetricDefinitionDto
     */
    @ApiOperation("创建指标定义")
    @PostMapping
    public ResponseData<MetricDefinitionDto> create(
            @Valid @RequestBody MetricDefinitionCreateParam createParam) {
        MetricDefinitionDto result = metricDefinitionService.create(createParam);
        return ResponseData.success(result);
    }
}
```

**反例：**
```typescript
// 缺少注释（错误）
export class MetricDefinitionService {
  async create(param: MetricCreateParam) {
    return this.http.post('/metrics', param);
  }
}

// 注释不完整（错误）
/**
 * 创建指标
 */
async create(param: MetricCreateParam) {
  // 缺少参数说明、返回值说明、异常说明
}
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "jsdoc/require-jsdoc": ["error", {
    "require": {
      "FunctionDeclaration": true,
      "MethodDefinition": true,
      "ClassDeclaration": true
    }
  }],
  "jsdoc/require-param": "error",
  "jsdoc/require-returns": "error"
}
```

### 规则 2.5.2：复杂业务逻辑必须添加行内注释说明
超过 10 行的复杂逻辑块必须添加注释说明。

**正例：**
```typescript
const validateMetricExpression = (expression: string): boolean => {
  // 检查表达式是否为空
  if (!expression || expression.trim().length === 0) {
    return false;
  }
  
  // 检查是否包含危险的 SQL 关键字
  const dangerousKeywords = ['DROP', 'DELETE', 'UPDATE', 'INSERT', 'TRUNCATE'];
  const upperExpression = expression.toUpperCase();
  
  for (const keyword of dangerousKeywords) {
    if (upperExpression.includes(keyword)) {
      return false;
    }
  }
  
  // 验证表达式的基本语法结构
  // 检查括号是否匹配
  let parenthesesCount = 0;
  for (const char of expression) {
    if (char === '(') {
      parenthesesCount++;
    } else if (char === ')') {
      parenthesesCount--;
      if (parenthesesCount < 0) {
        return false; // 右括号多于左括号
      }
    }
  }
  
  return parenthesesCount === 0; // 括号必须完全匹配
};
```

**反例：**
```typescript
// 复杂逻辑缺少注释（错误）
const validateMetricExpression = (expression: string): boolean => {
  if (!expression || expression.trim().length === 0) {
    return false;
  }
  
  const dangerousKeywords = ['DROP', 'DELETE', 'UPDATE', 'INSERT', 'TRUNCATE'];
  const upperExpression = expression.toUpperCase();
  
  for (const keyword of dangerousKeywords) {
    if (upperExpression.includes(keyword)) {
      return false;
    }
  }
  
  let parenthesesCount = 0;
  for (const char of expression) {
    if (char === '(') {
      parenthesesCount++;
    } else if (char === ')') {
      parenthesesCount--;
      if (parenthesesCount < 0) {
        return false;
      }
    }
  }
  
  return parenthesesCount === 0;
};
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "max-lines-per-function": ["warn", {
    "max": 50,
    "skipBlankLines": true,
    "skipComments": true
  }]
}
```

### 规则 2.5.3：TODO 注释必须包含责任人和截止时间
所有 TODO 注释必须标明责任人和预期完成时间。

**正例：**
```typescript
// TODO: @zhangsan 2024-02-01 实现指标表达式的语法高亮功能
const renderExpressionEditor = () => {
  return <Input.TextArea />;
};

// FIXME: @lisi 2024-01-15 修复指标删除时的权限检查问题
const deleteMetric = async (id: string) => {
  // 临时跳过权限检查
  await metricService.delete(id);
};
```

**反例：**
```typescript
// TODO: 实现语法高亮（错误：缺少责任人和时间）
// TODO 添加权限检查（错误：格式不规范）
// FIXME 修复删除问题（错误：缺少责任人和时间）
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "no-warning-comments": ["warn", {
    "terms": ["todo", "fixme"],
    "location": "start"
  }]
}
```

## 2.6 异常处理与日志

### 规则 2.6.1：前端使用统一的错误处理机制，后端异常必须分类处理
前端统一使用 try-catch 处理异步操作，后端按业务异常、系统异常分类处理。

**正例：**
```typescript
// 前端统一错误处理
const MetricManagementPage: React.FC = () => {
  const [loading, setLoading] = useState(false);
  const { t } = useTranslation();
  
  const handleCreateMetric = async (values: MetricCreateParam) => {
    setLoading(true);
    try {
      const result = await metricService.create(values);
      message.success(t('metric.create.success'));
      return result;
    } catch (error) {
      // 统一错误处理
      if (error.code === 'METRIC_CODE_EXISTS') {
        message.error(t('metric.code.exists'));
      } else if (error.code === 'PERMISSION_DENIED') {
        message.error(t('common.permission.denied'));
      } else {
        message.error(t('common.error.unknown'));
        console.error('创建指标失败:', error);
      }
      throw error;
    } finally {
      setLoading(false);
    }
  };
};
```

```java
// 后端分类异常处理
@Service
public class MetricDefinitionServiceImpl extends BaseService {
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public MetricDefinitionDto create(MetricDefinitionCreateParam createParam) {
        try {
            // 参数验证
            validateCreateParam(createParam);
            
            // 业务逻辑
            MetricDefinition metricDefinition = buildMetricDefinition(createParam);
            int result = metricDefinitionMapper.insert(metricDefinition);
            
            if (result <= 0) {
                throw new BusinessException("METRIC_CREATE_FAILED", "指标创建失败");
            }
            
            return entityToDto(metricDefinition);
            
        } catch (BusinessException e) {
            // 业务异常直接抛出
            log.warn("创建指标业务异常: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            // 系统异常包装后抛出
            log.error("创建指标系统异常", e);
            throw new SystemException("METRIC_CREATE_ERROR", "系统错误，请稍后重试", e);
        }
    }
    
    private void validateCreateParam(MetricDefinitionCreateParam param) {
        if (param == null) {
            throw new BusinessException("PARAM_NULL", "参数不能为空");
        }
        if (!StringUtils.hasText(param.getName())) {
            throw new BusinessException("METRIC_NAME_EMPTY", "指标名称不能为空");
        }
        if (checkCodeExists(param.getOrgId(), param.getCode(), null)) {
            throw new BusinessException("METRIC_CODE_EXISTS", "指标编码已存在");
        }
    }
}
```

**反例：**
```typescript
// 前端错误处理不统一（错误）
const handleCreateMetric = async (values: MetricCreateParam) => {
  metricService.create(values)
    .then(result => {
      message.success('创建成功');
    })
    .catch(error => {
      alert('创建失败'); // 不应使用 alert
    });
};
```

```java
// 后端异常处理不规范（错误）
public MetricDefinitionDto create(MetricDefinitionCreateParam createParam) {
    try {
        // 业务逻辑
        return result;
    } catch (Exception e) {
        e.printStackTrace(); // 不应直接打印堆栈
        return null;         // 不应返回 null
    }
}
```

**自动校验配置：**
```javascript
// .eslintrc.js - 前端
rules: {
  "prefer-promise-reject-errors": "error",
  "no-throw-literal": "error"
}
```

```xml
<!-- checkstyle.xml - 后端 -->
<module name="IllegalCatch">
    <property name="illegalClassNames" value="java.lang.Exception"/>
</module>
```

### 规则 2.6.2：日志级别使用规范，生产环境禁用 console.log
前端生产环境禁用 console，后端按 ERROR/WARN/INFO/DEBUG 分级记录。

**正例：**
```typescript
// 前端日志规范
import { logger } from 'app/utils/logger';

const MetricService = {
  async create(param: MetricCreateParam): Promise<MetricDefinitionDto> {
    logger.info('开始创建指标', { param });
    
    try {
      const result = await this.http.post('/metrics', param);
      logger.info('指标创建成功', { id: result.id, name: result.name });
      return result;
    } catch (error) {
      logger.error('指标创建失败', { error, param });
      throw error;
    }
  }
};
```

```java
// 后端日志规范
@Slf4j
@Service
public class MetricDefinitionServiceImpl {
    
    public MetricDefinitionDto create(MetricDefinitionCreateParam createParam) {
        log.info("开始创建指标定义, orgId: {}, name: {}", 
                createParam.getOrgId(), createParam.getName());
        
        try {
            MetricDefinition result = doCreate(createParam);
            log.info("指标定义创建成功, id: {}, code: {}", 
                    result.getId(), result.getCode());
            return entityToDto(result);
        } catch (BusinessException e) {
            log.warn("指标定义创建业务异常: {}, param: {}", e.getMessage(), createParam);
            throw e;
        } catch (Exception e) {
            log.error("指标定义创建系统异常, param: {}", createParam, e);
            throw new SystemException("系统错误", e);
        }
    }
}
```

**反例：**
```typescript
// 前端日志不规范（错误）
const create = async (param) => {
  console.log('创建指标', param);        // 生产环境会暴露敏感信息
  console.error('创建失败', error);      // 应使用统一日志工具
};
```

```java
// 后端日志不规范（错误）
public void create() {
    System.out.println("创建指标");       // 不应使用 System.out
    log.debug("重要业务信息");            // 重要信息不应使用 debug 级别
}
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "no-console": process.env.NODE_ENV === "production" ? "error" : "warn"
}
```

### 规则 2.6.3：敏感信息不得记录到日志中
密码、token、身份证号等敏感信息严禁记录到日志。

**正例：**
```typescript
// 前端敏感信息处理
const loginUser = async (credentials: LoginCredentials) => {
  logger.info('用户登录', { 
    username: credentials.username,
    // password: credentials.password,  // 密码不记录
    timestamp: Date.now()
  });
};
```

```java
// 后端敏感信息处理
public void login(UserLoginParam param) {
    log.info("用户登录, username: {}", param.getUsername());
    // 不记录密码: log.info("password: {}", param.getPassword());
}
```

**自动校验配置：**
```bash
# 检查敏感信息的脚本
grep -r "password\|token\|secret" --include="*.java" --include="*.ts" src/ | grep -i log
```

## 2.7 单元测试与集成测试

### 规则 2.7.1：单元测试覆盖率不低于 90%，核心业务逻辑必须 100% 覆盖
所有业务逻辑代码必须编写单元测试，覆盖率要求不低于 90%。

**正例：**
```typescript
// 前端单元测试
describe('MetricDefinitionService', () => {
  let service: MetricDefinitionService;
  let mockHttp: jest.Mocked<HttpClient>;

  beforeEach(() => {
    mockHttp = {
      post: jest.fn(),
      get: jest.fn(),
      put: jest.fn(),
      delete: jest.fn(),
    } as any;
    service = new MetricDefinitionService(mockHttp);
  });

  describe('create', () => {
    it('应该成功创建指标定义', async () => {
      // Arrange
      const createParam: MetricCreateParam = {
        name: '用户数',
        code: 'USER_COUNT',
        expression: 'COUNT(DISTINCT user_id)',
        orgId: 'org-1'
      };
      const expectedResult: MetricDefinitionDto = {
        id: 'metric-1',
        ...createParam,
        status: 'DRAFT'
      };
      mockHttp.post.mockResolvedValue(expectedResult);

      // Act
      const result = await service.create(createParam);

      // Assert
      expect(mockHttp.post).toHaveBeenCalledWith('/metrics', createParam);
      expect(result).toEqual(expectedResult);
    });

    it('当指标编码已存在时应该抛出异常', async () => {
      // Arrange
      const createParam: MetricCreateParam = {
        name: '用户数',
        code: 'EXISTING_CODE',
        expression: 'COUNT(*)',
        orgId: 'org-1'
      };
      mockHttp.post.mockRejectedValue(new BusinessException('METRIC_CODE_EXISTS'));

      // Act & Assert
      await expect(service.create(createParam)).rejects.toThrow('METRIC_CODE_EXISTS');
    });
  });
});
```

```java
// 后端单元测试
@ExtendWith(MockitoExtension.class)
class MetricDefinitionServiceImplTest {

    @Mock
    private MetricDefinitionMapperExt metricDefinitionMapper;
    
    @Mock
    private UserMapperExt userMapper;
    
    @InjectMocks
    private MetricDefinitionServiceImpl metricDefinitionService;

    @Test
    @DisplayName("创建指标定义 - 成功场景")
    void create_Success() {
        // Given
        MetricDefinitionCreateParam createParam = MetricDefinitionCreateParam.builder()
                .name("用户数")
                .code("USER_COUNT")
                .expression("COUNT(DISTINCT user_id)")
                .orgId("org-1")
                .build();
        
        when(metricDefinitionMapper.selectByOrgIdAndCode(anyString(), anyString()))
                .thenReturn(null);
        when(metricDefinitionMapper.insert(any(MetricDefinition.class)))
                .thenReturn(1);

        // When
        MetricDefinitionDto result = metricDefinitionService.create(createParam);

        // Then
        assertThat(result).isNotNull();
        assertThat(result.getName()).isEqualTo("用户数");
        assertThat(result.getCode()).isEqualTo("USER_COUNT");
        assertThat(result.getStatus()).isEqualTo("DRAFT");
        
        verify(metricDefinitionMapper).insert(any(MetricDefinition.class));
    }

    @Test
    @DisplayName("创建指标定义 - 编码已存在")
    void create_CodeExists_ThrowsException() {
        // Given
        MetricDefinitionCreateParam createParam = MetricDefinitionCreateParam.builder()
                .name("用户数")
                .code("EXISTING_CODE")
                .orgId("org-1")
                .build();
        
        MetricDefinition existingMetric = new MetricDefinition();
        existingMetric.setCode("EXISTING_CODE");
        when(metricDefinitionMapper.selectByOrgIdAndCode("org-1", "EXISTING_CODE"))
                .thenReturn(existingMetric);

        // When & Then
        assertThatThrownBy(() -> metricDefinitionService.create(createParam))
                .isInstanceOf(BusinessException.class)
                .hasMessageContaining("METRIC_CODE_EXISTS");
    }
}
```

**反例：**
```typescript
// 测试不充分（错误）
describe('MetricService', () => {
  it('should work', () => {
    expect(true).toBe(true); // 无意义的测试
  });
});
```

**自动校验配置：**
```json
// jest.config.js
{
  "coverageThreshold": {
    "global": {
      "branches": 90,
      "functions": 90,
      "lines": 90,
      "statements": 90
    }
  },
  "collectCoverageFrom": [
    "src/**/*.{js,jsx,ts,tsx}",
    "!src/**/*.d.ts",
    "!src/**/index.ts"
  ]
}
```

### 规则 2.7.2：测试文件命名规范，测试用例描述必须清晰
测试文件以 .test.ts/.spec.ts 结尾，测试用例使用中文描述。

**正例：**
```typescript
// MetricDefinitionService.test.ts
describe('MetricDefinitionService 指标定义服务', () => {
  describe('create 创建指标', () => {
    it('当参数正确时应该成功创建指标定义', async () => {});
    it('当指标编码已存在时应该抛出业务异常', async () => {});
    it('当参数为空时应该抛出参数异常', async () => {});
  });
  
  describe('update 更新指标', () => {
    it('当指标存在且有权限时应该成功更新', async () => {});
    it('当指标不存在时应该抛出未找到异常', async () => {});
    it('当无权限时应该抛出权限异常', async () => {});
  });
});
```

```java
// MetricDefinitionServiceImplTest.java
@DisplayName("指标定义服务测试")
class MetricDefinitionServiceImplTest {
    
    @Nested
    @DisplayName("创建指标定义")
    class CreateMetricDefinition {
        
        @Test
        @DisplayName("当参数正确时应该成功创建指标定义")
        void create_ValidParam_Success() {}
        
        @Test
        @DisplayName("当指标编码已存在时应该抛出业务异常")
        void create_CodeExists_ThrowsBusinessException() {}
    }
}
```

**反例：**
```typescript
// 命名和描述不规范（错误）
// metric.test.ts                    // 文件名应该更具体
describe('test', () => {             // 描述不清晰
  it('works', () => {});             // 用例描述不明确
  it('test create function', () => {}); // 应使用中文描述
});
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "jest/valid-describe-callback": "error",
  "jest/valid-title": ["error", {
    "mustMatch": {
      "describe": "^[\\u4e00-\\u9fa5].*$", // 中文开头
      "it": "^(当|应该|能够).*$"
    }
  }]
}
```

### 规则 2.7.3：集成测试使用真实数据库，测试数据必须隔离
集成测试使用独立的测试数据库，每个测试用例数据隔离。

**正例：**
```java
// 集成测试配置
@SpringBootTest
@Transactional
@Rollback
@TestPropertySource(locations = "classpath:application-test.yml")
class MetricDefinitionControllerIntegrationTest {

    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private MetricDefinitionMapper metricDefinitionMapper;
    
    @BeforeEach
    void setUp() {
        // 清理测试数据
        metricDefinitionMapper.deleteAll();
        
        // 准备测试数据
        prepareTestData();
    }
    
    @Test
    @DisplayName("创建指标定义接口集成测试")
    void createMetricDefinition_Integration() {
        // Given
        MetricDefinitionCreateParam param = MetricDefinitionCreateParam.builder()
                .name("集成测试指标")
                .code("INTEGRATION_TEST")
                .expression("COUNT(*)")
                .orgId("test-org")
                .build();
        
        // When
        ResponseEntity<ResponseData<MetricDefinitionDto>> response = 
                restTemplate.postForEntity("/api/v1/metrics", param, 
                        new ParameterizedTypeReference<ResponseData<MetricDefinitionDto>>() {});
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody().isSuccess()).isTrue();
        
        // 验证数据库状态
        List<MetricDefinition> metrics = metricDefinitionMapper.selectByOrgId("test-org");
        assertThat(metrics).hasSize(1);
        assertThat(metrics.get(0).getCode()).isEqualTo("INTEGRATION_TEST");
    }
}
```

**自动校验配置：**
```yaml
# application-test.yml
spring:
  datasource:
    url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    driver-class-name: org.h2.Driver
    username: sa
    password: 
  jpa:
    hibernate:
      ddl-auto: create-drop
```

## 2.8 Git 提交信息

### 规则 2.8.1：提交信息使用约定式提交格式
所有提交必须遵循 Conventional Commits 规范。

**正例：**
```bash
# 功能提交
feat(metric): 添加指标定义创建功能

- 实现指标定义的创建接口
- 添加指标编码唯一性校验
- 完善指标表达式验证逻辑

Closes #123

# 修复提交
fix(metric): 修复指标删除时的权限检查问题

修复了删除指标时未正确检查用户权限的问题，现在只有指标创建者
和组织管理员可以删除指标。

Fixes #456

# 文档提交
docs(api): 更新指标管理API文档

- 添加创建指标接口文档
- 完善错误码说明
- 更新接口示例

# 重构提交
refactor(service): 重构指标定义服务层代码

将指标定义服务的业务逻辑进行重构，提高代码可读性和可维护性，
没有改变对外接口。
```

**反例：**
```bash
# 提交信息不规范（错误）
update code                    # 描述不清晰
fix bug                       # 没有说明修复了什么bug
add new feature               # 没有说明具体功能
修复了一个问题                  # 应使用英文格式
feat: add metric function.    # 句号多余
```

**自动校验配置：**
```javascript
// commitlint.config.js
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [2, 'always', [
      'feat', 'fix', 'docs', 'style', 'refactor', 
      'perf', 'test', 'chore', 'revert'
    ]],
    'subject-max-length': [2, 'always', 50],
    'body-max-line-length': [2, 'always', 72]
  }
};
```

### 规则 2.8.2：每次提交只包含一个逻辑变更，提交粒度要合适
每个提交应该是一个完整的、可独立理解的变更。

**正例：**
```bash
# 单一职责的提交
git commit -m "feat(metric): 添加指标编码唯一性校验"
git commit -m "test(metric): 添加指标创建功能的单元测试"
git commit -m "docs(metric): 更新指标管理接口文档"
```

**反例：**
```bash
# 包含多个不相关变更（错误）
git commit -m "feat: 添加指标功能，修复用户登录bug，更新文档"

# 提交粒度过细（错误）
git commit -m "fix: 修复变量名拼写错误"
git commit -m "fix: 调整代码缩进"
git commit -m "fix: 删除多余空行"
```

### 规则 2.8.3：分支命名规范，使用 feature/fix/hotfix 前缀
分支名称必须使用规范前缀，并包含简短描述。

**正例：**
```bash
# 功能分支
feature/metric-definition-management
feature/user-permission-control
feature/dashboard-export

# 修复分支
fix/metric-delete-permission-check
fix/login-session-timeout

# 热修复分支
hotfix/security-vulnerability-fix
hotfix/data-loss-prevention
```

**反例：**
```bash
# 分支命名不规范（错误）
dev                           # 描述不清晰
zhangsan-dev                  # 不应使用个人名称
metric_management             # 应使用短横线
fix-bug                       # 描述不具体
```

**自动校验配置：**
```bash
# .git/hooks/pre-push
#!/bin/sh
branch=$(git rev-parse --abbrev-ref HEAD)
valid_pattern="^(feature|fix|hotfix|release)\/[a-z0-9-]+$"

if [[ ! $branch =~ $valid_pattern ]]; then
  echo "分支名称不符合规范: $branch"
  echo "请使用格式: feature/description 或 fix/description"
  exit 1
fi
```

## 2.9 Lint/Checkstyle/Spotless 配置

### 规则 2.9.1：前端使用 ESLint + Prettier + Stylelint 组合
前端代码质量检查使用统一的 Lint 工具链。

**正例：**
```javascript
// .eslintrc.js
module.exports = {
  extends: [
    'react-app',
    'react-app/jest',
    '@typescript-eslint/recommended',
    'prettier'
  ],
  plugins: ['prettier', 'jsdoc', '@typescript-eslint'],
  rules: {
    'prettier/prettier': ['error'],
    '@typescript-eslint/no-unused-vars': ['error'],
    '@typescript-eslint/explicit-function-return-type': ['warn'],
    'jsdoc/require-jsdoc': ['error', {
      require: {
        FunctionDeclaration: true,
        MethodDefinition: true,
        ClassDeclaration: true
      }
    }],
    'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'warn',
    'prefer-const': 'error',
    'no-var': 'error'
  },
  parserOptions: {
    ecmaVersion: 2020,
    sourceType: 'module',
    ecmaFeatures: {
      jsx: true
    },
    project: './tsconfig.json'
  }
};
```

```json
// .prettierrc
{
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "semi": true,
  "singleQuote": true,
  "trailingComma": "all",
  "arrowParens": "avoid",
  "endOfLine": "auto",
  "bracketSpacing": true,
  "jsxBracketSameLine": false
}
```

```javascript
// stylelint.config.js
module.exports = {
  extends: [
    'stylelint-config-standard',
    'stylelint-config-prettier',
    'stylelint-config-recess-order'
  ],
  plugins: [
    'stylelint-config-styled-components'
  ],
  rules: {
    'indentation': 2,
    'string-quotes': 'single',
    'no-duplicate-selectors': true,
    'color-hex-case': 'lower',
    'color-hex-length': 'short',
    'selector-max-id': 0,
    'selector-combinator-space-after': 'always',
    'selector-attribute-quotes': 'always',
    'declaration-colon-space-after': 'always',
    'declaration-colon-space-before': 'never',
    'block-opening-brace-space-before': 'always',
    'rule-empty-line-before': ['always', {
      except: ['first-nested'],
      ignore: ['after-comment']
    }]
  }
};
```

**自动校验配置：**
```json
// package.json
{
  "scripts": {
    "lint": "eslint --ext .js,.jsx,.ts,.tsx src/",
    "lint:fix": "eslint --ext .js,.jsx,.ts,.tsx src/ --fix",
    "lint:css": "stylelint \"src/**/*.css\"",
    "lint:style": "stylelint \"src/**/*.{js,ts,jsx,tsx}\"",
    "format": "prettier --write \"src/**/*.{js,jsx,ts,tsx,json,css,md}\"",
    "type-check": "tsc --noEmit"
  },
  "lint-staged": {
    "*.{js,jsx,ts,tsx}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{css,scss}": [
      "stylelint --fix",
      "prettier --write"
    ]
  }
}
```

### 规则 2.9.2：后端使用 Checkstyle + SpotBugs + PMD 组合
后端代码质量检查使用 Maven 插件集成。

**正例：**
```xml
<!-- pom.xml -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-checkstyle-plugin</artifactId>
    <version>3.1.2</version>
    <configuration>
        <configLocation>checkstyle.xml</configLocation>
        <encoding>UTF-8</encoding>
        <consoleOutput>true</consoleOutput>
        <failsOnError>true</failsOnError>
        <includeTestSourceDirectory>true</includeTestSourceDirectory>
    </configuration>
    <executions>
        <execution>
            <id>validate</id>
            <phase>validate</phase>
            <goals>
                <goal>check</goal>
            </goals>
        </execution>
    </executions>
</plugin>

<plugin>
    <groupId>com.github.spotbugs</groupId>
    <artifactId>spotbugs-maven-plugin</artifactId>
    <version>4.7.3.0</version>
    <configuration>
        <effort>Max</effort>
        <threshold>Low</threshold>
        <xmlOutput>true</xmlOutput>
    </configuration>
    <executions>
        <execution>
            <goals>
                <goal>check</goal>
            </goals>
        </execution>
    </executions>
</plugin>

<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-pmd-plugin</artifactId>
    <version>3.17.0</version>
    <configuration>
        <rulesets>
            <ruleset>/category/java/bestpractices.xml</ruleset>
            <ruleset>/category/java/codestyle.xml</ruleset>
            <ruleset>/category/java/design.xml</ruleset>
            <ruleset>/category/java/errorprone.xml</ruleset>
            <ruleset>/category/java/performance.xml</ruleset>
        </rulesets>
        <printFailingErrors>true</printFailingErrors>
    </configuration>
    <executions>
        <execution>
            <goals>
                <goal>check</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

```xml
<!-- checkstyle.xml -->
<?xml version="1.0"?>
<!DOCTYPE module PUBLIC
    "-//Checkstyle//DTD Checkstyle Configuration 1.3//EN"
    "https://checkstyle.org/dtds/configuration_1_3.dtd">

<module name="Checker">
    <property name="charset" value="UTF-8"/>
    <property name="severity" value="warning"/>
    <property name="fileExtensions" value="java, properties, xml"/>

    <module name="LineLength">
        <property name="max" value="120"/>
        <property name="ignorePattern" value="^package.*|^import.*|a href|href|http://|https://|ftp://"/>
    </module>

    <module name="TreeWalker">
        <module name="OuterTypeFilename"/>
        <module name="IllegalTokenText">
            <property name="tokens" value="STRING_LITERAL, CHAR_LITERAL"/>
            <property name="format" value="\\u00(09|0(a|A)|0(c|C)|0(d|D)|22|27|5(C|c))|\\(0(10|11|12|14|15|42|47)|134)"/>
            <property name="message" value="Consider using special escape sequence instead of octal value or Unicode escaped value."/>
        </module>
        
        <!-- 命名约定 -->
        <module name="PackageName">
            <property name="format" value="^[a-z]+(\.[a-z][a-z0-9]*)*$"/>
        </module>
        <module name="TypeName">
            <property name="format" value="^[A-Z][a-zA-Z0-9]*$"/>
        </module>
        <module name="MemberName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        <module name="MethodName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        <module name="LocalVariableName">
            <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
        </module>
        <module name="ConstantName">
            <property name="format" value="^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$"/>
        </module>
        
        <!-- 代码格式 -->
        <module name="Indentation">
            <property name="basicOffset" value="4"/>
            <property name="braceAdjustment" value="0"/>
            <property name="caseIndent" value="4"/>
        </module>
        <module name="LeftCurly"/>
        <module name="RightCurly"/>
        <module name="WhitespaceAround"/>
        <module name="WhitespaceAfter"/>
        
        <!-- 代码质量 -->
        <module name="EmptyBlock"/>
        <module name="NeedBraces"/>
        <module name="AvoidNestedBlocks"/>
        <module name="MissingSwitchDefault"/>
        <module name="FallThrough"/>
        <module name="UpperEll"/>
        <module name="ModifierOrder"/>
        <module name="EmptyLineSeparator">
            <property name="allowNoEmptyLineBetweenFields" value="true"/>
        </module>
        <module name="SeparatorWrap">
            <property name="id" value="SeparatorWrapDot"/>
            <property name="tokens" value="DOT"/>
            <property name="option" value="nl"/>
        </module>
    </module>
</module>
```

### 规则 2.9.3：CI/CD 流水线集成代码检查，检查失败阻止合并
所有代码检查工具必须集成到 CI/CD 流水线中。

**正例：**
```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  frontend-check:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '16'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
    
    - name: Install dependencies
      run: |
        cd frontend
        npm ci
    
    - name: Type check
      run: |
        cd frontend
        npm run type-check
    
    - name: Lint check
      run: |
        cd frontend
        npm run lint
    
    - name: Style check
      run: |
        cd frontend
        npm run lint:css
        npm run lint:style
    
    - name: Run tests
      run: |
        c
# Datart 项目代码风格和规范

本文档是 datart 项目的官方编码规范，适用于前端（React/TypeScript）和后端（Java/Spring Boot）开发。所有开发者必须严格遵循此规范。

## 2.1 目录与文件命名

### 规则 2.1.1：前端目录使用 camelCase，组件目录使用 PascalCase
前端普通目录使用小驼峰命名，React 组件目录使用大驼峰命名。

**正例：**
```
frontend/src/
├── app/
├── components/
│   ├── ChartGraph/
│   │   └── BasicOutlineMapChart/
│   └── DataTable/
├── pages/
│   └── MainPage/
├── utils/
└── types/
```

**反例：**
```
frontend/src/
├── App/           # 普通目录不应使用大驼峰
├── chart-graph/   # 组件目录不应使用短横线
├── data_table/    # 不应使用下划线
└── Utils/         # 普通目录不应使用大驼峰
```

**自动校验配置：**
```bash
# .eslintrc.js 中添加文件命名规则
rules: {
  "unicorn/filename-case": [
    "error",
    {
      "cases": {
        "camelCase": true,
        "pascalCase": true
      }
    }
  ]
}
```

### 规则 2.1.2：后端包名使用全小写，类文件使用 PascalCase
Java 包名必须全小写，类文件名必须与类名一致使用大驼峰命名。

**正例：**
```
server/src/main/java/datart/server/
├── controller/
│   ├── MetricDefinitionController.java
│   └── UserController.java
├── service/
│   └── impl/
│       └── MetricDefinitionServiceImpl.java
└── base/
    ├── dto/
    └── params/
```

**反例：**
```
server/src/main/java/datart/server/
├── Controller/                    # 包名不应大写
├── Service_Impl/                  # 包名不应使用下划线
├── metricDefinitionController.java # 类文件名应与类名一致
└── metric-controller.java         # 不应使用短横线
```

**自动校验配置：**
```xml
<!-- checkstyle.xml -->
<module name="PackageName">
    <property name="format" value="^[a-z]+(\.[a-z][a-z0-9]*)*$"/>
</module>
<module name="TypeName">
    <property name="format" value="^[A-Z][a-zA-Z0-9]*$"/>
</module>
```

### 规则 2.1.3：配置文件使用短横线命名
所有配置文件统一使用短横线分隔命名。

**正例：**
```
.eslintrc.js
.prettierrc
application.yml
application-dev.yml
tsconfig.json
package.json
```

**反例：**
```
eslint_config.js    # 不应使用下划线
prettier.config.js  # 应使用 .prettierrc
applicationDev.yml  # 不应使用驼峰
```

**自动校验配置：**
```bash
# 在 package.json 的 scripts 中添加
"check-config": "find . -name '*.config.js' -o -name '*_config.*' | grep -v node_modules && exit 1 || exit 0"
```

## 2.2 模块与包结构

### 规则 2.2.1：前端按功能模块组织，最大嵌套深度不超过 4 层
前端代码按业务功能模块组织，目录嵌套深度不得超过 4 层。

**正例：**
```typescript
// src/app/pages/MainPage/pages/MetricPage/index.tsx
export const MetricPage: React.FC = () => {
  return <div>Metric Management</div>;
};

// 目录结构深度：src(1)/app(2)/pages(3)/MainPage(4) ✓
```

**反例：**
```typescript
// src/app/pages/main/components/metric/management/list/item/index.tsx
// 目录结构深度超过 4 层 ✗
```

**自动校验配置：**
```bash
# 检查目录深度的脚本
find src -type d | awk -F'/' 'NF > 6 {print "目录深度超过4层: " $0; exit 1}'
```

### 规则 2.2.2：后端采用分层架构，包结构固定为 controller/service/mapper
后端严格按照 MVC 分层架构组织，包结构层次固定。

**正例：**
```java
// datart.server.controller.MetricDefinitionController
@RestController
@RequestMapping("/metrics")
public class MetricDefinitionController extends BaseController {
    private final MetricDefinitionService metricDefinitionService;
}

// datart.server.service.impl.MetricDefinitionServiceImpl
@Service
public class MetricDefinitionServiceImpl extends BaseService 
    implements MetricDefinitionService {
}
```

**反例：**
```java
// 不应将业务逻辑写在 Controller 中
@RestController
public class MetricController {
    public ResponseData create() {
        // 直接在 Controller 中写业务逻辑 ✗
        MetricDefinition metric = new MetricDefinition();
        // ... 复杂业务逻辑
    }
}
```

**自动校验配置：**
```xml
<!-- maven-checkstyle-plugin 配置 -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-checkstyle-plugin</artifactId>
    <configuration>
        <configLocation>checkstyle.xml</configLocation>
        <includeTestSourceDirectory>true</includeTestSourceDirectory>
    </configuration>
</plugin>
```

### 规则 2.2.3：每个模块的导入语句不超过 20 个
单个文件的 import 语句数量不得超过 20 个，超过则需要重构。

**正例：**
```typescript
// 导入语句控制在合理范围内
import React, { useState, useEffect } from 'react';
import { Button, Table, Modal } from 'antd';
import { useTranslation } from 'react-i18next';
import { MetricDefinitionDto } from 'app/types/MetricDefinition';
import { metricService } from 'app/services/metricService';
// ... 总计不超过 20 个导入
```

**反例：**
```typescript
// 导入过多，需要重构
import React from 'react';
import { useState } from 'react';
import { useEffect } from 'react';
// ... 超过 20 个单独的导入语句 ✗
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "import/max-dependencies": ["error", {"max": 20}]
}
```

## 2.3 变量、函数、类、接口命名

### 规则 2.3.1：前端变量和函数使用 camelCase，常量使用 SCREAMING_SNAKE_CASE
TypeScript/JavaScript 变量和函数使用小驼峰，常量使用全大写下划线。

**正例：**
```typescript
// 变量和函数
const metricDefinition = new MetricDefinition();
const isLoading = false;
const handleSubmit = () => {};
const getUserProfile = async () => {};

// 常量
const API_BASE_URL = 'http://localhost:8080/api/v1';
const MAX_RETRY_COUNT = 3;
const DEFAULT_PAGE_SIZE = 20;
```

**反例：**
```typescript
// 变量命名错误
const MetricDefinition = {};     // 应使用 camelCase
const is_loading = false;        // 不应使用下划线
const HandleSubmit = () => {};   // 函数不应使用 PascalCase

// 常量命名错误
const apiBaseUrl = 'http://...'; // 常量应使用 SCREAMING_SNAKE_CASE
const maxRetryCount = 3;         // 常量应使用 SCREAMING_SNAKE_CASE
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "camelcase": ["error", {
    "properties": "always",
    "ignoreDestructuring": false,
    "ignoreImports": false,
    "ignoreGlobals": false
  }],
  "@typescript-eslint/naming-convention": [
    "error",
    {
      "selector": "variable",
      "format": ["camelCase", "UPPER_CASE"]
    },
    {
      "selector": "function",
      "format": ["camelCase"]
    }
  ]
}
```

### 规则 2.3.2：后端类名使用 PascalCase，方法和变量使用 camelCase
Java 类名使用大驼峰，方法名和变量名使用小驼峰。

**正例：**
```java
// 类名
public class MetricDefinitionController extends BaseController {
    
    // 成员变量
    private final MetricDefinitionService metricDefinitionService;
    
    // 方法名
    public ResponseData<MetricDefinitionDto> create(
        @Valid @RequestBody MetricDefinitionCreateParam createParam) {
        MetricDefinitionDto result = metricDefinitionService.create(createParam);
        return ResponseData.success(result);
    }
    
    // 局部变量
    private void validateMetricCode(String orgId, String code) {
        boolean codeExists = metricDefinitionService.checkCodeExists(orgId, code, null);
        if (codeExists) {
            throw new BusinessException("指标编码已存在");
        }
    }
}
```

**反例：**
```java
// 类名错误
public class metricDefinitionController {  // 应使用 PascalCase
public class Metric_Definition_Service {   // 不应使用下划线

// 方法名错误
public ResponseData Create() {}            // 应使用 camelCase
public void Validate_Code() {}             // 不应使用下划线

// 变量名错误
private String MetricName;                 // 应使用 camelCase
private boolean is_valid;                  // 不应使用下划线
```

**自动校验配置：**
```xml
<!-- checkstyle.xml -->
<module name="MethodName">
    <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
</module>
<module name="MemberName">
    <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
</module>
<module name="LocalVariableName">
    <property name="format" value="^[a-z][a-zA-Z0-9]*$"/>
</module>
```

### 规则 2.3.3：接口名以 I 开头，DTO 类以 Dto 结尾，参数类以 Param 结尾
接口、DTO、参数类必须按照固定后缀命名。

**正例：**
```typescript
// 前端接口定义
interface IMetricDefinition {
  id: string;
  name: string;
  code: string;
}

interface IMetricService {
  create(param: MetricCreateParam): Promise<MetricDefinitionDto>;
  update(param: MetricUpdateParam): Promise<MetricDefinitionDto>;
}
```

```java
// 后端类定义
public class MetricDefinitionDto {
    private String id;
    private String name;
    private String code;
}

public class MetricDefinitionCreateParam {
    @NotBlank
    private String name;
    @NotBlank
    private String code;
}
```

**反例：**
```typescript
// 接口命名错误
interface MetricDefinition {}      // 应以 I 开头
interface MetricServiceInterface {} // 不应使用 Interface 后缀
```

```java
// 类命名错误
public class MetricDefinition {}    // DTO 应以 Dto 结尾
public class MetricCreateRequest {} // 参数类应以 Param 结尾
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "@typescript-eslint/naming-convention": [
    "error",
    {
      "selector": "interface",
      "format": ["PascalCase"],
      "prefix": ["I"]
    }
  ]
}
```

## 2.4 代码格式与缩进

### 规则 2.4.1：使用 2 个空格缩进，行宽限制 80 字符
所有代码文件统一使用 2 个空格缩进，单行长度不超过 80 字符。

**正例：**
```typescript
// 2 个空格缩进，行宽 80 字符内
const MetricDefinitionForm: React.FC<IProps> = ({ 
  initialValues, 
  onSubmit 
}) => {
  const [form] = Form.useForm();
  const { t } = useTranslation();
  
  const handleSubmit = async (values: MetricCreateParam) => {
    try {
      await onSubmit(values);
      message.success(t('common.success'));
    } catch (error) {
      message.error(t('common.error'));
    }
  };
  
  return (
    <Form
      form={form}
      layout="vertical"
      initialValues={initialValues}
      onFinish={handleSubmit}
    >
      <Form.Item
        name="name"
        label={t('metric.name')}
        rules={[{ required: true, message: t('metric.name.required') }]}
      >
        <Input placeholder={t('metric.name.placeholder')} />
      </Form.Item>
    </Form>
  );
};
```

**反例：**
```typescript
// 4 个空格缩进（错误）
const MetricDefinitionForm: React.FC<IProps> = ({ initialValues, onSubmit }) => {
    const [form] = Form.useForm();
    
    // 行宽超过 80 字符（错误）
    const handleSubmit = async (values: MetricCreateParam) => {
        try {
            await onSubmit(values);
            message.success('操作成功，指标定义已创建，请查看指标列表确认结果');
        } catch (error) {
            message.error('操作失败，请检查网络连接和输入参数是否正确，然后重试');
        }
    };
};
```

**自动校验配置：**
```json
// .prettierrc
{
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "semi": true,
  "singleQuote": true,
  "trailingComma": "all",
  "arrowParens": "avoid",
  "endOfLine": "auto"
}
```

### 规则 2.4.2：Java 代码使用 4 个空格缩进，行宽限制 120 字符
Java 代码使用 4 个空格缩进，单行长度不超过 120 字符。

**正例：**
```java
@RestController
@RequestMapping("/metrics")
@Validated
public class MetricDefinitionController extends BaseController {

    private final MetricDefinitionService metricDefinitionService;

    public MetricDefinitionController(MetricDefinitionService metricDefinitionService) {
        this.metricDefinitionService = metricDefinitionService;
    }

    @ApiOperation("创建指标定义")
    @PostMapping
    public ResponseData<MetricDefinitionDto> create(
            @Valid @RequestBody MetricDefinitionCreateParam createParam) {
        MetricDefinitionDto result = metricDefinitionService.create(createParam);
        return ResponseData.success(result);
    }

    @ApiOperation("根据状态获取组织下的指标列表")
    @GetMapping("/org/{orgId}/status/{status}")
    public ResponseData<List<MetricDefinitionDto>> listByOrgIdAndStatus(
            @ApiParam("组织ID") @PathVariable @NotBlank String orgId,
            @ApiParam("状态") @PathVariable @NotBlank String status) {
        List<MetricDefinitionDto> result = 
            metricDefinitionService.listByOrgIdAndStatus(orgId, status);
        return ResponseData.success(result);
    }
}
```

**反例：**
```java
// 2 个空格缩进（错误）
@RestController
public class MetricDefinitionController {
  private final MetricDefinitionService service;
  
  // 行宽超过 120 字符（错误）
  public ResponseData<List<MetricDefinitionDto>> listByOrgIdAndStatus(@PathVariable String orgId, @PathVariable String status) {
    return ResponseData.success(metricDefinitionService.listByOrgIdAndStatus(orgId, status));
  }
}
```

**自动校验配置：**
```xml
<!-- checkstyle.xml -->
<module name="Indentation">
    <property name="basicOffset" value="4"/>
    <property name="braceAdjustment" value="0"/>
    <property name="caseIndent" value="4"/>
</module>
<module name="LineLength">
    <property name="max" value="120"/>
    <property name="ignorePattern" value="^package.*|^import.*|a href|href|http://|https://|ftp://"/>
</module>
```

### 规则 2.4.3：大括号使用 K&R 风格，左大括号不换行
所有语言统一使用 K&R 大括号风格。

**正例：**
```typescript
// TypeScript K&R 风格
if (condition) {
  doSomething();
} else {
  doSomethingElse();
}

const obj = {
  name: 'metric',
  code: 'M001',
};

function handleSubmit() {
  if (isValid) {
    submit();
  }
}
```

```java
// Java K&R 风格
if (condition) {
    doSomething();
} else {
    doSomethingElse();
}

public void create() {
    if (isValid()) {
        save();
    }
}
```

**反例：**
```typescript
// Allman 风格（错误）
if (condition) 
{
  doSomething();
}

// GNU 风格（错误）
if (condition)
  {
    doSomething();
  }
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "brace-style": ["error", "1tbs", { "allowSingleLine": true }]
}
```

## 2.5 注释与文档注释

### 规则 2.5.1：所有公共 API 必须有 JSDoc/JavaDoc 注释
公共接口、类、方法必须提供完整的文档注释。

**正例：**
```typescript
/**
 * 指标定义服务
 * 提供指标的创建、更新、删除、查询等功能
 */
export class MetricDefinitionService {
  
  /**
   * 创建指标定义
   * @param param 创建参数
   * @param param.name 指标名称，必填，长度1-50字符
   * @param param.code 指标编码，必填，组织内唯一
   * @param param.expression 指标表达式，必填
   * @returns Promise<MetricDefinitionDto> 创建成功的指标信息
   * @throws {BusinessException} 当指标编码已存在时抛出异常
   * @example
   * ```typescript
   * const result = await metricService.create({
   *   name: '用户数',
   *   code: 'USER_COUNT',
   *   expression: 'COUNT(DISTINCT user_id)'
   * });
   * ```
   */
  async create(param: MetricCreateParam): Promise<MetricDefinitionDto> {
    return this.http.post('/metrics', param);
  }
}
```

```java
/**
 * 指标定义控制器
 * 提供指标定义的 REST API 接口
 * 
 * @author datart-team
 * @since 1.0.0
 */
@RestController
@RequestMapping("/metrics")
public class MetricDefinitionController extends BaseController {

    /**
     * 创建指标定义
     * 
     * @param createParam 创建参数，包含指标名称、编码、表达式等信息
     * @return ResponseData<MetricDefinitionDto> 包装的响应数据，包含创建成功的指标信息
     * @throws BusinessException 当指标编码已存在或参数验证失败时抛出
     * @see MetricDefinitionCreateParam
     * @see MetricDefinitionDto
     */
    @ApiOperation("创建指标定义")
    @PostMapping
    public ResponseData<MetricDefinitionDto> create(
            @Valid @RequestBody MetricDefinitionCreateParam createParam) {
        MetricDefinitionDto result = metricDefinitionService.create(createParam);
        return ResponseData.success(result);
    }
}
```

**反例：**
```typescript
// 缺少注释（错误）
export class MetricDefinitionService {
  async create(param: MetricCreateParam) {
    return this.http.post('/metrics', param);
  }
}

// 注释不完整（错误）
/**
 * 创建指标
 */
async create(param: MetricCreateParam) {
  // 缺少参数说明、返回值说明、异常说明
}
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "jsdoc/require-jsdoc": ["error", {
    "require": {
      "FunctionDeclaration": true,
      "MethodDefinition": true,
      "ClassDeclaration": true
    }
  }],
  "jsdoc/require-param": "error",
  "jsdoc/require-returns": "error"
}
```

### 规则 2.5.2：复杂业务逻辑必须添加行内注释说明
超过 10 行的复杂逻辑块必须添加注释说明。

**正例：**
```typescript
const validateMetricExpression = (expression: string): boolean => {
  // 检查表达式是否为空
  if (!expression || expression.trim().length === 0) {
    return false;
  }
  
  // 检查是否包含危险的 SQL 关键字
  const dangerousKeywords = ['DROP', 'DELETE', 'UPDATE', 'INSERT', 'TRUNCATE'];
  const upperExpression = expression.toUpperCase();
  
  for (const keyword of dangerousKeywords) {
    if (upperExpression.includes(keyword)) {
      return false;
    }
  }
  
  // 验证表达式的基本语法结构
  // 检查括号是否匹配
  let parenthesesCount = 0;
  for (const char of expression) {
    if (char === '(') {
      parenthesesCount++;
    } else if (char === ')') {
      parenthesesCount--;
      if (parenthesesCount < 0) {
        return false; // 右括号多于左括号
      }
    }
  }
  
  return parenthesesCount === 0; // 括号必须完全匹配
};
```

**反例：**
```typescript
// 复杂逻辑缺少注释（错误）
const validateMetricExpression = (expression: string): boolean => {
  if (!expression || expression.trim().length === 0) {
    return false;
  }
  
  const dangerousKeywords = ['DROP', 'DELETE', 'UPDATE', 'INSERT', 'TRUNCATE'];
  const upperExpression = expression.toUpperCase();
  
  for (const keyword of dangerousKeywords) {
    if (upperExpression.includes(keyword)) {
      return false;
    }
  }
  
  let parenthesesCount = 0;
  for (const char of expression) {
    if (char === '(') {
      parenthesesCount++;
    } else if (char === ')') {
      parenthesesCount--;
      if (parenthesesCount < 0) {
        return false;
      }
    }
  }
  
  return parenthesesCount === 0;
};
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "max-lines-per-function": ["warn", {
    "max": 50,
    "skipBlankLines": true,
    "skipComments": true
  }]
}
```

### 规则 2.5.3：TODO 注释必须包含责任人和截止时间
所有 TODO 注释必须标明责任人和预期完成时间。

**正例：**
```typescript
// TODO: @zhangsan 2024-02-01 实现指标表达式的语法高亮功能
const renderExpressionEditor = () => {
  return <Input.TextArea />;
};

// FIXME: @lisi 2024-01-15 修复指标删除时的权限检查问题
const deleteMetric = async (id: string) => {
  // 临时跳过权限检查
  await metricService.delete(id);
};
```

**反例：**
```typescript
// TODO: 实现语法高亮（错误：缺少责任人和时间）
// TODO 添加权限检查（错误：格式不规范）
// FIXME 修复删除问题（错误：缺少责任人和时间）
```

**自动校验配置：**
```javascript
// .eslintrc.js
rules: {
  "no-warning-comments": ["warn", {
    "terms": ["todo", "fixme"],
    "location": "start"
  }]
}
```

## 2.6 异常处理与日志

### 规则 2.6.1：前端使用统一的错误处理机制，后端异常必须分类处理
前端统一使用 try-catch 处理异步操作，后端按业务异常、系统异常分类处理。

**正例：**
```typescript
// 前端统一错误处理
const MetricManagementPage: React.FC = () => {
  const [loading, setLoading] = useState(false);
  const { t } = useTranslation();
  
  const handleCreateMetric = async (values: MetricCreateParam) => {
    setLoading(true);
    try {
      const result = await metricService.create(values);
      message.success(t('metric.create.success'));
      return result;
    } catch (error) {
      // 统一错误处理
      if (error.code === 'METRIC_CODE_EXISTS') {
        message.error(t('metric.code.exists'));
      } else if (error.code === 'PERMISSION_DENIED') {
        message.error(t('common.permission.denied'));
      } else {
        message.error(t('common.error.unknown'));
        console.error('创建指标失败:', error);
      }
      throw error;
    } finally {
      setLoading(false);
    }
  };
};
```

```java
// 后端分类异常处理
@Service
public class MetricDefinitionServiceImpl extends BaseService {
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public MetricDefinitionDto create(MetricDefinitionCreateParam createParam) {
        try {
            // 参数验证
            validateCreateParam(createParam);
            
            // 业务逻辑
            MetricDefinition metricDefinition = buildMetricDefinition(createParam);
            int result = metricDefinitionMapper.insert(metricDefinition);
            
            if (result <= 0) {
                throw new BusinessException("METRIC_CREATE_FAILED", "指标创建失败");
            }
            
            return entityToDto(metricDefinition);
            
        } catch (BusinessException e) {
            // 业务异常直接抛出
            log.warn("创建指标业务异常: {}", e.getMessage());
            throw e;
        } catch (Exception e) {
            // 系统异常包装后抛出
            log.error("创建指标系统异常", e);
            throw new SystemException("METRIC_CREATE_ERROR", "系统错误，请稍后重试", e);
        }
    }
    
    private void validateCreateParam(MetricDefinitionCreateParam param) {
        if (param == null) {
            throw new BusinessException("PARAM_NULL", "参数不能为空");
        }
        if (!StringUtils.hasText(param.getName())) {
            throw new BusinessException("METRIC_NAME_EMPTY", "指标名称不能为空");
        }
        if (checkCodeExists(param.getOrgId(), param.getCode(), null)) {
            throw new BusinessException("METRIC_CODE_EXISTS", "指标编码已存在");
        }
    }
}
```

**反例：**
```typescript
// 前端错误处理不统一（错误）
const handleCreateMetric = async (values: MetricCreateParam) => {
  metricService.create(values)
    .then(result => {
      message.success('创建成功');
    })
    .catch(error => {
      alert('创建失败'); // 不应使用 alert
    });
};
```

```java
// 后端异常处理不规范（错误）
public MetricDefinitionDto create(MetricDefinitionCreateParam createParam) {
    try {
        // 业务逻辑
        return result;